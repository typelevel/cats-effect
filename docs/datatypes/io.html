<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>IO · Cats Effect</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A data type for encoding side effects as pure values, capable of"/><meta name="docsearch:version" content="2.x"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="IO · Cats Effect"/><meta property="og:type" content="website"/><meta property="og:url" content="https://typelevel.org/cats-effect/"/><meta property="og:description" content="A data type for encoding side effects as pure values, capable of"/><meta property="og:image" content="https://typelevel.org/cats-effect/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://typelevel.org/cats-effect/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/cats-effect/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/cats-effect/js/scrollSpy.js"></script><link rel="stylesheet" href="/cats-effect/css/main.css"/><script src="/cats-effect/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/cats-effect/"><img class="logo" src="/cats-effect/img/favicon.png" alt="Cats Effect"/><h2 class="headerTitleWithLogo">Cats Effect</h2></a><a href="/cats-effect/versions"><h3>2.x</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/cats-effect/docs/installation" target="_self">Docs</a></li><li class=""><a href="https://github.com/typelevel/cats-effect" target="_blank">GitHub</a></li><li class=""><a href="/cats-effect/api/index.html" target="_self">API</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Data Types</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Getting Started<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/installation">Installation</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Guides<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/guides/tutorial">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/guides/tracing">Tracing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Data Types<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/cats-effect/docs/datatypes/io">IO</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/syncio">SyncIO</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/fiber">Fiber</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/resource">Resource</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/clock">Clock</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/contextshift">ContextShift</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/timer">Timer</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/datatypes/ioapp">IOApp</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Concurrency<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/basics">Basics</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/deferred">Deferred</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/mvar">MVar</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/ref">Ref</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/concurrency/semaphore">Semaphore</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Type Classes<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/bracket">Bracket</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/sync">Sync</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/liftio">LiftIO</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/async">Async</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/concurrent">Concurrent</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/effect">Effect</a></li><li class="navListItem"><a class="navItem" href="/cats-effect/docs/typeclasses/concurrenteffect">ConcurrentEffect</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">IO</h1></header><article><div><span><p>A data type for encoding side effects as pure values, capable of
expressing both synchronous and asynchronous computations.</p>
<p><nav role="navigation" id="toc"></nav></p>
<h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p>A value of type <code>IO[A]</code> is a computation which, when evaluated, can
perform effects before returning a value of type <code>A</code>.</p>
<p><code>IO</code> values are pure, immutable values and thus preserves referential
transparency, being usable in functional programming. An <code>IO</code> is a
data structure that represents just a description of a side effectful
computation.</p>
<p><code>IO</code> can describe synchronous or asynchronous computations that:</p>
<ol>
<li>on evaluation yield exactly one result</li>
<li>can end in either success or failure and in case of failure
<code>flatMap</code> chains get short-circuited (<code>IO</code> implementing the algebra
of <code>MonadError</code>)</li>
<li>can be canceled, but note this capability relies on the
user to provide cancellation logic</li>
</ol>
<p>Effects described via this abstraction are not evaluated until the
&quot;end of the world&quot;, which is to say, when one of the &quot;unsafe&quot; methods
are used. Effectful results are not memoized, meaning that memory
overhead is minimal (and no leaks), and also that a single effect may
be run multiple times in a referentially-transparent manner. For
example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">val</span> ioa = <span class="hljs-type">IO</span> { println(<span class="hljs-string">"hey!"</span>) }

<span class="hljs-keyword">val</span> program: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-keyword">for</span> {
     _ &lt;- ioa
     _ &lt;- ioa
  } <span class="hljs-keyword">yield</span> ()

program.unsafeRunSync()
<span class="hljs-comment">//=&gt; hey!</span>
<span class="hljs-comment">//=&gt; hey!</span>
()
</code></pre>
<p>The above example prints &quot;hey!&quot; twice, as the effect re-runs each time
it is sequenced in the monadic chain.</p>
<h3><a class="anchor" aria-hidden="true" id="on-referential-transparency-and-lazy-evaluation"></a><a href="#on-referential-transparency-and-lazy-evaluation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>On Referential Transparency and Lazy Evaluation</h3>
<p><code>IO</code> can suspend side effects and is thus a lazily evaluated data type, being many times compared with <code>Future</code> from the standard library and to understand the landscape in terms of the evaluation model (in Scala), consider this classification:</p>
<table>
<thead>
<tr><th style="text-align:center"></th><th style="text-align:center">Eager</th><th style="text-align:center">Lazy</th></tr>
</thead>
<tbody>
<tr><td style="text-align:center"><strong>Synchronous</strong></td><td style="text-align:center">A</td><td style="text-align:center">() =&gt; A</td></tr>
<tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://typelevel.org/cats/datatypes/eval.html">Eval[A]</a></td></tr>
<tr><td style="text-align:center"><strong>Asynchronous</strong></td><td style="text-align:center">(A =&gt; Unit) =&gt; Unit</td><td style="text-align:center">() =&gt; (A =&gt; Unit) =&gt; Unit</td></tr>
<tr><td style="text-align:center"></td><td style="text-align:center">Future[A]</td><td style="text-align:center">IO[A]</td></tr>
</tbody>
</table>
<p>In comparison with Scala's <code>Future</code>, the <code>IO</code> data type preserves <em>referential transparency</em> even when dealing with side effects and is lazily evaluated. In an eager language like Scala, this is the difference between a result and the function producing it.</p>
<p>Similar with <code>Future</code>, with <code>IO</code> you can reason about the results of asynchronous processes, but due to its purity and laziness <code>IO</code> can be thought of as a specification (to be evaluated at the &quot;<em>end of the world</em>&quot;), yielding more control over the evaluation model and being more predictable, for example when dealing with sequencing vs parallelism, when composing multiple IOs or when dealing with failure.</p>
<p>Note laziness goes hand in hand with referential transparency. Consider this example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  _ &lt;- addToGauge(<span class="hljs-number">32</span>)
  _ &lt;- addToGauge(<span class="hljs-number">32</span>)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>If we have referential transparency, we can rewrite that example as:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> task = addToGauge(<span class="hljs-number">32</span>)

<span class="hljs-keyword">for</span> {
  _ &lt;- task
  _ &lt;- task
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>This doesn't work with <code>Future</code>, but works with <code>IO</code> and this ability is essential for <em>functional programming</em>.</p>
<h3><a class="anchor" aria-hidden="true" id="stack-safety"></a><a href="#stack-safety" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stack Safety</h3>
<p><code>IO</code> is trampolined in its <code>flatMap</code> evaluation. This means that you
can safely call <code>flatMap</code> in a recursive function of arbitrary depth,
without fear of blowing the stack:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>, a: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>, b: <span class="hljs-type">Long</span> = <span class="hljs-number">1</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Long</span>] =
  <span class="hljs-type">IO</span>(a + b).flatMap { b2 =&gt;
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) 
      fib(n - <span class="hljs-number">1</span>, b, b2)
    <span class="hljs-keyword">else</span> 
      <span class="hljs-type">IO</span>.pure(a)
  }
</code></pre>
<p><code>IO</code> implements all the typeclasses shown in the <a href="/cats-effect/docs/typeclasses/overview">hierarchy</a>. Therefore
all those operations are available for <code>IO</code>, in addition to some
others.</p>
<h2><a class="anchor" aria-hidden="true" id="describing-effects"></a><a href="#describing-effects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Describing Effects</h2>
<p><code>IO</code> is a potent abstraction that can efficiently describe multiple
kinds of effects:</p>
<h3><a class="anchor" aria-hidden="true" id="pure-values--iopure--iounit"></a><a href="#pure-values--iopure--iounit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pure Values — IO.pure &amp; IO.unit</h3>
<p>You can lift pure values into <code>IO</code>, yielding <code>IO</code> values that are
&quot;already evaluated&quot;, the following function being defined on IO's
companion:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>Note that the given parameter is passed by value, not by name.</p>
<p>For example we can lift a number (pure value) into <code>IO</code> and compose it
with another <code>IO</code> that wraps a side a effect in a safe manner, as
nothing is going to be executed:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.pure(<span class="hljs-number">25</span>).flatMap(n =&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">s"Number is: <span class="hljs-subst">$n</span>"</span>)))
</code></pre>
<p>It should be obvious that <code>IO.pure</code> cannot suspend side effects, because
<code>IO.pure</code> is eagerly evaluated, with the given parameter being passed
by value, so don't do this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.pure(println(<span class="hljs-string">"THIS IS WRONG!"</span>))
</code></pre>
<p>In this case the <code>println</code> will trigger a side effect that is not
suspended in <code>IO</code> and given this code that probably is not our
intention.</p>
<p><code>IO.unit</code> is simply an alias for <code>IO.pure(())</code>, being a reusable
reference that you can use when an <code>IO[Unit]</code> value is required, but
you don't need to trigger any other side effects:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> unit: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.pure(())
</code></pre>
<p>Given <code>IO[Unit]</code> is so prevalent in Scala code, the <code>Unit</code> type itself
being meant to signal completion of side effectful routines, this
proves useful as a shortcut and as an optimization, since the same
reference is returned.</p>
<h3><a class="anchor" aria-hidden="true" id="synchronous-effects--ioapply"></a><a href="#synchronous-effects--ioapply" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Synchronous Effects — IO.apply</h3>
<p>It's probably the most used builder and the equivalent of
<code>Sync[IO].delay</code>, describing <code>IO</code> operations that can be evaluated
immediately, on the current thread and call-stack:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](body: =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>Note the given parameter is passed ''by name'', its execution being
&quot;suspended&quot; in the <code>IO</code> context.</p>
<p>An example would be reading / writing from / to the console, which on
top of the JVM uses blocking I/O, so their execution is immediate:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">putStrLn</span></span>(value: <span class="hljs-type">String</span>) = <span class="hljs-type">IO</span>(println(value))
<span class="hljs-keyword">val</span> readLn = <span class="hljs-type">IO</span>(scala.io.<span class="hljs-type">StdIn</span>.readLine())
</code></pre>
<p>And then we can use that to model interactions with the console in a
purely functional way:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  _ &lt;- putStrLn(<span class="hljs-string">"What's your name?"</span>)
  n &lt;- readLn
  _ &lt;- putStrLn(<span class="hljs-string">s"Hello, <span class="hljs-subst">$n</span>!"</span>)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="asynchronous-effects--ioasync--iocancelable"></a><a href="#asynchronous-effects--ioasync--iocancelable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous Effects — IO.async &amp; IO.cancelable</h3>
<p><code>IO</code> can describe asynchronous processes via the <code>IO.async</code> and
<code>IO.cancelable</code> builders.</p>
<p><code>IO.async</code> is the operation that complies with the laws of
<code>Async#async</code> (see <a href="/cats-effect/docs/typeclasses/async">Async</a>) and can
describe simple asynchronous processes that cannot be canceled,
its signature being:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">async</span></span>[<span class="hljs-type">A</span>](k: (<span class="hljs-type">Either</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Unit</span>) =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>The provided registration function injects a callback that you can use
to signal either successful results (with <code>Right(a)</code>), or failures
(with <code>Left(error)</code>). Users can trigger whatever asynchronous side
effects are required, then use the injected callback to signal
completion.</p>
<p>For example, you don't need to convert Scala's <code>Future</code>, because you
already have a conversion operation defined in <code>IO.fromFuture</code>,
however the code for converting a <code>Future</code> would be straightforward:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.{<span class="hljs-type">Future</span>, <span class="hljs-type">ExecutionContext</span>}
<span class="hljs-keyword">import</span> scala.util.{<span class="hljs-type">Success</span>, <span class="hljs-type">Failure</span>}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span></span>[<span class="hljs-type">A</span>](fa: =&gt; <span class="hljs-type">Future</span>[<span class="hljs-type">A</span>])(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] =
  <span class="hljs-type">IO</span>.async { cb =&gt;
    <span class="hljs-comment">// This triggers evaluation of the by-name param and of onComplete, </span>
    <span class="hljs-comment">// so it's OK to have side effects in this callback</span>
    fa.onComplete {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Success</span>(a) =&gt; cb(<span class="hljs-type">Right</span>(a))
      <span class="hljs-keyword">case</span> <span class="hljs-type">Failure</span>(e) =&gt; cb(<span class="hljs-type">Left</span>(e))
    }
  }
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="cancelable-processes"></a><a href="#cancelable-processes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cancelable Processes</h4>
<p>For building cancelable <code>IO</code> tasks you need to use the
<code>IO.cancelable</code> builder, this being compliant with
<code>Concurrent#cancelable</code> (see <a href="/cats-effect/docs/typeclasses/concurrent">Concurrent</a>)
and has this signature:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cancelable</span></span>[<span class="hljs-type">A</span>](k: (<span class="hljs-type">Either</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">Unit</span>) =&gt; <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>So it is similar with <code>IO.async</code>, but in that registration function
the user is expected to provide an <code>IO[Unit]</code> that captures the
required cancellation logic.</p>
<p>Important: cancellation is the ability to interrupt an <code>IO</code> task before
completion, possibly releasing any acquired resources, useful in race
conditions to prevent leaks.</p>
<p>As example suppose we want to describe a <code>sleep</code> operation that
depends on Java's <code>ScheduledExecutorService</code>, delaying a tick for a
certain time duration:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">ScheduledExecutorService</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delayedTick</span></span>(d: <span class="hljs-type">FiniteDuration</span>)
  (<span class="hljs-keyword">implicit</span> sc: <span class="hljs-type">ScheduledExecutorService</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = {
 
  <span class="hljs-type">IO</span>.cancelable { cb =&gt;
    <span class="hljs-keyword">val</span> r = <span class="hljs-keyword">new</span> <span class="hljs-type">Runnable</span> { <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>() = cb(<span class="hljs-type">Right</span>(())) }
    <span class="hljs-keyword">val</span> f = sc.schedule(r, d.length, d.unit)
    
    <span class="hljs-comment">// Returning the cancellation token needed to cancel </span>
    <span class="hljs-comment">// the scheduling and release resources early</span>
    <span class="hljs-type">IO</span>(f.cancel(<span class="hljs-literal">false</span>)).void
  }
}
</code></pre>
<p>Note this delayed tick is already described by <code>IO.sleep</code> (via
<code>Timer</code>), so you don't need to do it.</p>
<p>More on dealing with ''cancellation'' below.</p>
<h4><a class="anchor" aria-hidden="true" id="ionever"></a><a href="#ionever" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.never</h4>
<p><code>IO.never</code> represents a non-terminating <code>IO</code> defined in terms of
<code>async</code>, useful as shortcut and as a reusable reference:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> never: <span class="hljs-type">IO</span>[<span class="hljs-type">Nothing</span>] = <span class="hljs-type">IO</span>.async(_ =&gt; ())
</code></pre>
<p>This is useful in order to use non-termination in certain cases, like
race conditions. For example, given <code>IO.race</code>, we have these
equivalences:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.race(lh, <span class="hljs-type">IO</span>.never) &lt;-&gt; lh.map(<span class="hljs-type">Left</span>(_))

<span class="hljs-type">IO</span>.race(<span class="hljs-type">IO</span>.never, rh) &lt;-&gt; rh.map(<span class="hljs-type">Right</span>(_))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="deferred-execution--iosuspend"></a><a href="#deferred-execution--iosuspend" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deferred Execution — IO.suspend</h3>
<p>The <code>IO.suspend</code> builder has this equivalence:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.suspend(f) &lt;-&gt; <span class="hljs-type">IO</span>(f).flatten
</code></pre>
<p>So it is useful for suspending effects, but that defers the completion
of the returned <code>IO</code> to some other reference. It's also useful for
modeling stack safe, tail recursive loops:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>, a: <span class="hljs-type">Long</span>, b: <span class="hljs-type">Long</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Long</span>] =
  <span class="hljs-type">IO</span>.suspend {
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)
      fib(n - <span class="hljs-number">1</span>, b, a + b)
    <span class="hljs-keyword">else</span>
      <span class="hljs-type">IO</span>.pure(a)
  }
</code></pre>
<p>Normally a function like this would eventually yield a stack overflow
error on top of the JVM. By using <code>IO.suspend</code> and doing all of those
cycles using <code>IO</code>'s run-loop, its evaluation is lazy and it's going to
use constant memory. This would work with <code>flatMap</code> as well, of
course, <code>suspend</code> being just nicer in this example.</p>
<p>We could describe this function using Scala's <code>@tailrec</code> mechanism,
however by using <code>IO</code> we can also preserve fairness by inserting
asynchronous boundaries:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>, a: <span class="hljs-type">Long</span>, b: <span class="hljs-type">Long</span>)(<span class="hljs-keyword">implicit</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">Long</span>] =
  <span class="hljs-type">IO</span>.suspend {
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-type">IO</span>.pure(a) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">val</span> next = fib(n - <span class="hljs-number">1</span>, b, a + b)
      <span class="hljs-comment">// Every 100 cycles, introduce a logical thread fork</span>
      <span class="hljs-keyword">if</span> (n % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)
        cs.shift *&gt; next
      <span class="hljs-keyword">else</span>
        next
    }
  }
</code></pre>
<p>And now we have something more interesting than a <code>@tailrec</code> loop. As
can be seen, <code>IO</code> allows very precise control over the evaluation.</p>
<h2><a class="anchor" aria-hidden="true" id="concurrency-and-cancellation"></a><a href="#concurrency-and-cancellation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrency and Cancellation</h2>
<p><code>IO</code> can describe interruptible asynchronous processes. As an
implementation detail:</p>
<ol>
<li>not all <code>IO</code> tasks are cancelable. Cancellation status is only checked <em>after</em>
asynchronous boundaries. It can be achieved in the following way:</li>
</ol>
<ul>
<li>Building it with <code>IO.cancelable</code>, <code>IO.async</code>, <code>IO.asyncF</code> or <code>IO.bracket</code></li>
<li>Using <code>IO.cancelBoundary</code> or <code>IO.shift</code></li>
</ul>
<p>Note that the second point is the consequence of the first one and anything that involves
those operations is also possible to cancel. It includes, but is not limited to
waiting on <code>Mvar.take</code>, <code>Mvar.put</code> and <code>Deferred.get</code>.</p>
<p>We should also note that <code>flatMap</code> chains are only cancelable only if
the chain happens <em>after</em> an asynchronous boundary.
After an asynchronous boundary, cancellation checks are performed on every N <code>flatMap</code>.
The value of <code>N</code> is hardcoded to 512.</p>
<p>Here is an example,</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retryUntilRight</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](io: <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]]): <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>] = {
  io.flatMap {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(b) =&gt; <span class="hljs-type">IO</span>.pure(b)
    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(_) =&gt; retryUntilRight(io)
  }
}

<span class="hljs-comment">// non-terminating IO that is NOT cancelable</span>
<span class="hljs-keyword">val</span> notCancelable: <span class="hljs-type">IO</span>[<span class="hljs-type">Int</span>] = retryUntilRight(<span class="hljs-type">IO</span>(<span class="hljs-type">Left</span>(<span class="hljs-number">0</span>)))

<span class="hljs-comment">// non-terminating IO that is cancelable because there is an</span>
<span class="hljs-comment">// async boundary created by IO.shift before `flatMap` chain</span>
<span class="hljs-keyword">val</span> cancelable: <span class="hljs-type">IO</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">IO</span>.shift *&gt; retryUntilRight(<span class="hljs-type">IO</span>(<span class="hljs-type">Left</span>(<span class="hljs-number">0</span>)))
</code></pre>
<ol start="2">
<li><code>IO</code> tasks that are cancelable, usually become non-terminating on
<code>cancel</code></li>
</ol>
<p>Also this might be a point of confusion for folks coming from Java and
that expect the features of <code>Thread.interrupt</code> or of the old and
deprecated <code>Thread.stop</code>:</p>
<p><code>IO</code> cancellation does NOT work like that, as thread interruption in
Java is inherently <em>unsafe, unreliable and not portable</em>!</p>
<p>Next subsections describe cancellation-related operations in more depth.</p>
<h3><a class="anchor" aria-hidden="true" id="building-cancelable-io-tasks"></a><a href="#building-cancelable-io-tasks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building cancelable IO tasks</h3>
<p>Cancelable <code>IO</code> tasks can be described via the <code>IO.cancelable</code>
builder. The <code>delayedTick</code> example making use of the Java's
<code>ScheduledExecutorService</code> was already given above, but to recap:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">ScheduledExecutorService</span>

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.duration.<span class="hljs-type">FiniteDuration</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span></span>(d: <span class="hljs-type">FiniteDuration</span>)
  (<span class="hljs-keyword">implicit</span> sc: <span class="hljs-type">ScheduledExecutorService</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = {

  <span class="hljs-type">IO</span>.cancelable { cb =&gt; 
    <span class="hljs-keyword">val</span> r = <span class="hljs-keyword">new</span> <span class="hljs-type">Runnable</span> { <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>() = cb(<span class="hljs-type">Right</span>(())) }
    <span class="hljs-keyword">val</span> f = sc.schedule(r, d.length, d.unit)
    <span class="hljs-comment">// Returning a function that can cancel our scheduling</span>
    <span class="hljs-type">IO</span>(f.cancel(<span class="hljs-literal">false</span>)).void
  }
}
</code></pre>
<p>Important: if you don't specify cancellation logic for a task, then the task
is NOT cancelable. So for example, using Java's blocking I/O still:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unsafeFileToString</span></span>(file: <span class="hljs-type">File</span>) = {
  <span class="hljs-comment">// Freaking Java :-)</span>
  <span class="hljs-keyword">val</span> in = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileInputStream</span>(file), <span class="hljs-string">"utf-8"</span>))
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Uninterruptible loop</span>
    <span class="hljs-keyword">val</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>()
    <span class="hljs-keyword">var</span> hasNext = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">while</span> (hasNext) {
      hasNext = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">val</span> line = in.readLine()
      <span class="hljs-keyword">if</span> (line != <span class="hljs-literal">null</span>) {
        hasNext = <span class="hljs-literal">true</span>
        sb.append(line)
      }
    }
    sb.toString
  } <span class="hljs-keyword">finally</span> {
    in.close()
  }
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFile</span></span>(file: <span class="hljs-type">File</span>)(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>) =
  <span class="hljs-type">IO</span>.async[<span class="hljs-type">String</span>] { cb =&gt;
    ec.execute(() =&gt; {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Signal completion</span>
        cb(<span class="hljs-type">Right</span>(unsafeFileToString(file)))
      } <span class="hljs-keyword">catch</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt;
          cb(<span class="hljs-type">Left</span>(e))
      }
    })
  }
</code></pre>
<p>This is obviously not cancelable and there's no magic that the <code>IO</code>
implementation does to make that loop cancelable. No, we are not going
to use Java's <code>Thread.interrupt</code>, because that would be unsafe and
unreliable and besides, whatever the <code>IO</code> does has to be portable
between platforms.</p>
<p>But there's a lot of flexibility in what can be done, including here.
We could simply introduce a variable that changes to <code>false</code>, to be
observed in that <code>while</code> loop:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">File</span>
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.<span class="hljs-type">AtomicBoolean</span>

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.io.<span class="hljs-type">Source</span>
<span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unsafeFileToString</span></span>(file: <span class="hljs-type">File</span>, isActive: <span class="hljs-type">AtomicBoolean</span>) = {
  <span class="hljs-keyword">val</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>
  <span class="hljs-keyword">val</span> linesIterator = <span class="hljs-type">Source</span>.fromFile(file).getLines()
  <span class="hljs-keyword">var</span> hasNext = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">while</span> (hasNext &amp;&amp; isActive.get) {
    sc.append(linesIterator.next())
    hasNext = linesIterator.hasNext
  }
  sc.toString
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFile</span></span>(file: <span class="hljs-type">File</span>)(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>) =
  <span class="hljs-type">IO</span>.cancelable[<span class="hljs-type">String</span>] { cb =&gt;
    <span class="hljs-keyword">val</span> isActive = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicBoolean</span>(<span class="hljs-literal">true</span>)
    
    ec.execute(() =&gt; {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Signal completion</span>
        cb(<span class="hljs-type">Right</span>(unsafeFileToString(file, isActive)))
      } <span class="hljs-keyword">catch</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt;
          cb(<span class="hljs-type">Left</span>(e))
      }
    })    
    <span class="hljs-comment">// On cancel, signal it</span>
    <span class="hljs-type">IO</span>(isActive.set(<span class="hljs-literal">false</span>)).void
  }
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="gotcha-cancellation-is-a-concurrent-action"></a><a href="#gotcha-cancellation-is-a-concurrent-action" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gotcha: Cancellation is a Concurrent Action!</h4>
<p>This is not always obvious, not from the above examples, but you might
be tempted to do something like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readLine</span></span>(in: <span class="hljs-type">BufferedReader</span>)(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>) =
  <span class="hljs-type">IO</span>.cancelable[<span class="hljs-type">String</span>] { cb =&gt;
    ec.execute(() =&gt; cb(
      <span class="hljs-keyword">try</span> <span class="hljs-type">Right</span>(in.readLine()) 
      <span class="hljs-keyword">catch</span> { <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt; <span class="hljs-type">Left</span>(e) }))
      
    <span class="hljs-comment">// Cancellation logic is not thread-safe!</span>
    <span class="hljs-type">IO</span>(in.close()).void
  }
</code></pre>
<p>An operation like this might be useful in streaming abstractions that
stream I/O chunks via <code>IO</code> (via libraries like FS2, Monix, or others).</p>
<p>But the described operation is incorrect, because <code>in.close()</code> is
<em>concurrent</em> with <code>in.readLine</code>, which can lead to thrown exceptions
and in many cases it can lead to data <em>corruption</em>. This is a big
no-no. We want to interrupt whatever it is that the <code>IO</code> is doing, but
not at the cost of data corruption.</p>
<p>Therefore the user needs to handle thread safety concerns. So here's
one way of doing it:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.<span class="hljs-type">AtomicBoolean</span>

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.util.control.<span class="hljs-type">NonFatal</span>
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readLine</span></span>(in: <span class="hljs-type">BufferedReader</span>)(<span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>) =
  <span class="hljs-type">IO</span>.cancelable[<span class="hljs-type">String</span>] { cb =&gt;
    <span class="hljs-keyword">val</span> isActive = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicBoolean</span>(<span class="hljs-literal">true</span>)
    ec.execute { () =&gt; 
      <span class="hljs-keyword">if</span> (isActive.getAndSet(<span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">try</span> cb(<span class="hljs-type">Right</span>(in.readLine()))
        <span class="hljs-keyword">catch</span> { <span class="hljs-keyword">case</span> <span class="hljs-type">NonFatal</span>(e) =&gt; cb(<span class="hljs-type">Left</span>(e)) }
      }
      <span class="hljs-comment">// Note there's no else; if cancellation was executed</span>
      <span class="hljs-comment">// then we don't call the callback; task becoming </span>
      <span class="hljs-comment">// non-terminating ;-)</span>
    }
    <span class="hljs-comment">// Cancellation logic</span>
    <span class="hljs-type">IO</span> {
      <span class="hljs-comment">// Thread-safe gate</span>
      <span class="hljs-keyword">if</span> (isActive.getAndSet(<span class="hljs-literal">false</span>))
        in.close()
    }.void
  }
</code></pre>
<p>In this example it is the cancellation logic itself that calls
<code>in.close()</code>, but the call is safe due to the thread-safe guard that
we're creating by usage of an atomic <code>getAndSet</code>.</p>
<p>This is using an <code>AtomicBoolean</code> for thread-safety, but don't shy away
from using intrinsic locks / mutexes via <code>synchronize</code> blocks or
whatever else concurrency primitives the JVM provides, whatever is
needed in these side effectful functions. And don't worry, this is
usually needed only in <code>IO.cancelable</code>, <code>IO.async</code> or <code>IO.apply</code>, as
these builders represents the FFI for interacting with the impure
world, aka the dark side, otherwise once you're in <code>IO</code>'s context, you
can compose concurrent tasks using higher level tools.</p>
<p>Shared memory concurrency is unfortunately both the blessing and the
curse of working with kernel threads. Not a big problem on N:1
platforms like JavaScript, but there you don't get in-process CPU
parallelism either. Such is life, a big trail of tradeoffs.</p>
<h3><a class="anchor" aria-hidden="true" id="concurrent-start--cancel"></a><a href="#concurrent-start--cancel" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrent start + cancel</h3>
<p>You can use <code>IO</code> as a green-threads system, with the &quot;fork&quot; operation
being available via <code>IO#start</code>, the operation that's compliant with
<code>Concurrent#start</code>. This is a method with the following signature:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span></span>: <span class="hljs-type">IO</span>[<span class="hljs-type">Fiber</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">A</span>]]
</code></pre>
<p>Returned is a <a href="/cats-effect/docs/datatypes/fiber">Fiber</a>. You can think of fibers as being
lightweight threads, a fiber being the pure and light equivalent of a
thread that can be either joined (via <code>join</code>) or interrupted (via
<code>cancel</code>).</p>
<p>Example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-comment">// Needed for IO.start to do a logical thread fork</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> launchMissiles: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"boom!"</span>))
<span class="hljs-keyword">val</span> runToBunker = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"To the bunker!!!"</span>))

<span class="hljs-keyword">for</span> {
  fiber &lt;- launchMissiles.start
  _ &lt;- runToBunker.handleErrorWith { error =&gt;
    <span class="hljs-comment">// Retreat failed, cancel launch (maybe we should</span>
    <span class="hljs-comment">// have retreated to our bunker before the launch?)</span>
    fiber.cancel *&gt; <span class="hljs-type">IO</span>.raiseError(error)
  }
  aftermath &lt;- fiber.join
} <span class="hljs-keyword">yield</span> aftermath
</code></pre>
<p>Implementation notes:</p>
<ul>
<li>the <code>*&gt;</code> operator is defined in Cats and you can treat it as an
alias for <code>lh.flatMap(_ =&gt; rh)</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="runcancelable--unsaferuncancelable"></a><a href="#runcancelable--unsaferuncancelable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>runCancelable &amp; unsafeRunCancelable</h3>
<p>The above is the pure <code>cancel</code>, accessible via <code>Fiber</code>. However the
second way to access cancellation token and thus interrupt tasks is via
<code>runCancelable</code> (the pure version) and <code>unsafeRunCancelable</code> (the
unsafe version).</p>
<p>Example relying on the side-effecting <code>unsafeRunCancelable</code> and note
this kind of code is impure and should be used with care:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-comment">// Needed for `sleep`</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-comment">// Delayed println</span>
<span class="hljs-keyword">val</span> io: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.sleep(<span class="hljs-number">10.</span>seconds) *&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Hello!"</span>))

<span class="hljs-keyword">val</span> cancel: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = 
  io.unsafeRunCancelable(r =&gt; println(<span class="hljs-string">s"Done: <span class="hljs-subst">$r</span>"</span>))

<span class="hljs-comment">// ... if a race condition happens, we can cancel it,</span>
<span class="hljs-comment">// thus canceling the scheduling of `IO.sleep`</span>
cancel.unsafeRunSync()
</code></pre>
<p>The <code>runCancelable</code> alternative is the operation that's compliant with
the laws of <a href="/cats-effect/docs/typeclasses/concurrenteffect">ConcurrentEffect</a>.
Same idea, only the actual execution is suspended in <code>SyncIO</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">SyncIO</span>
<span class="hljs-keyword">import</span> cats.syntax.flatMap._

<span class="hljs-keyword">val</span> pureResult: <span class="hljs-type">SyncIO</span>[<span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>]] = io.runCancelable { r =&gt; 
  <span class="hljs-type">IO</span>(println(<span class="hljs-string">s"Done: <span class="hljs-subst">$r</span>"</span>))
}

<span class="hljs-comment">// On evaluation, this will first execute the source, then it </span>
<span class="hljs-comment">// will cancel it, because it makes perfect sense :-)</span>
pureResult.toIO.flatten
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="uncancelable-marker"></a><a href="#uncancelable-marker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>uncancelable marker</h3>
<p>Given a cancelable <code>IO</code>, we can turn it into an <code>IO</code> that cannot be
canceled:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-comment">// Needed for `sleep`</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-comment">// Our reference from above</span>
<span class="hljs-keyword">val</span> io: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.sleep(<span class="hljs-number">10.</span>seconds) *&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Hello!"</span>))

<span class="hljs-comment">// This IO can't be canceled, even if we try</span>
io.uncancelable
</code></pre>
<p>Sometimes you need to ensure that an <code>IO</code>'s execution is <em>atomic</em>, or
in other words, either all of it executes, or none of it. And this is
what this operation does — cancelable IOs are by definition not atomic
and in certain cases we need to make them atomic.</p>
<p>This law is compliant with the laws of <code>Concurrent#uncancelable</code> (see
<a href="/cats-effect/docs/typeclasses/concurrent">Concurrent</a>).</p>
<h3><a class="anchor" aria-hidden="true" id="iocancelboundary"></a><a href="#iocancelboundary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO.cancelBoundary</h3>
<p>Returns a cancelable boundary — an <code>IO</code> task that checks for the
cancellation status of the run-loop and does not allow for the bind
continuation to keep executing in case cancellation happened.</p>
<p>This operation is very similar to <code>IO.shift</code>, as it can be dropped in
<code>flatMap</code> chains in order to make such long loops cancelable:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>, a: <span class="hljs-type">Long</span>, b: <span class="hljs-type">Long</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Long</span>] =
  <span class="hljs-type">IO</span>.suspend {
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-type">IO</span>.pure(a) <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">val</span> next = fib(n - <span class="hljs-number">1</span>, b, a + b)

      <span class="hljs-comment">// Every 100-th cycle check cancellation status</span>
      <span class="hljs-keyword">if</span> (n % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)
        <span class="hljs-type">IO</span>.cancelBoundary *&gt; next
      <span class="hljs-keyword">else</span>
        next
    }
  }
</code></pre>
<p>As mentioned at the very beginning of this section, fairness needs to be managed explicitly,
the protocol being easy to follow and predictable in a WYSIWYG fashion.</p>
<h4><a class="anchor" aria-hidden="true" id="comparison-to-ioshift"></a><a href="#comparison-to-ioshift" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison to IO.shift</h4>
<p><code>IO.cancelBoundary</code> is essentially lighter version of <code>IO.shift</code> without
ability to shift into different thread pool. It is lighter in the sense that
it will avoid doing logical fork.</p>
<h3><a class="anchor" aria-hidden="true" id="race-conditions--race--racepair"></a><a href="#race-conditions--race--racepair" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Race Conditions — race &amp; racePair</h3>
<p>A race condition is a piece of logic that creates a race between two
or more tasks, with the winner being signaled immediately, with the
losers being usually canceled.</p>
<p><code>IO</code> provides two operations for races in its companion:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// simple version</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">race</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](lh: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], rh: <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>])
  (<span class="hljs-keyword">implicit</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]]
  
<span class="hljs-comment">// advanced version</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">racePair</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](lh: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], rh: <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>])
  (<span class="hljs-keyword">implicit</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[(<span class="hljs-type">A</span>, <span class="hljs-type">Fiber</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">B</span>]), (<span class="hljs-type">Fiber</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">A</span>], <span class="hljs-type">B</span>)]]
</code></pre>
<p>The simple version, <code>IO.race</code>, will cancel the loser immediately,
whereas the second version gives you a <a href="/cats-effect/docs/datatypes/fiber">Fiber</a>, letting
you decide what to do next.</p>
<p>So <code>race</code> can be derived with <code>racePair</code> like so:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">race</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](lh: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], rh: <span class="hljs-type">IO</span>[<span class="hljs-type">B</span>])
  (<span class="hljs-keyword">implicit</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">Either</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]] = {
  
  <span class="hljs-type">IO</span>.racePair(lh, rh).flatMap {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>((a, fiber)) =&gt; 
      fiber.cancel.map(_ =&gt; <span class="hljs-type">Left</span>(a))
    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>((fiber, b)) =&gt; 
      fiber.cancel.map(_ =&gt; <span class="hljs-type">Right</span>(b))
  }
}
</code></pre>
<p>Using <code>race</code> we could implement a &quot;timeout&quot; operation:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>, <span class="hljs-type">IO</span>}

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">CancellationException</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration.<span class="hljs-type">FiniteDuration</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeoutTo</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], after: <span class="hljs-type">FiniteDuration</span>, fallback: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>])
  (<span class="hljs-keyword">implicit</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>], cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = {

  <span class="hljs-type">IO</span>.race(fa, timer.sleep(after)).flatMap {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Left</span>(a) =&gt; <span class="hljs-type">IO</span>.pure(a)
    <span class="hljs-keyword">case</span> <span class="hljs-type">Right</span>(_) =&gt; fallback
  }
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeout</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], after: <span class="hljs-type">FiniteDuration</span>)
  (<span class="hljs-keyword">implicit</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>], cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = {

  <span class="hljs-keyword">val</span> error = <span class="hljs-keyword">new</span> <span class="hljs-type">CancellationException</span>(after.toString)
  timeoutTo(fa, after, <span class="hljs-type">IO</span>.raiseError(error))
}
</code></pre>
<p>See <em>Parallelism</em> section above for how to obtain a <code>Timer[IO]</code></p>
<h3><a class="anchor" aria-hidden="true" id="comparison-with-haskells-async-interruption"></a><a href="#comparison-with-haskells-async-interruption" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison with Haskell's &quot;async interruption&quot;</h3>
<p>Haskell treats interruption with what they call &quot;asynchronous
exceptions&quot;, providing the ability to interrupt a running task by
throwing an exception from another thread (concurrently).</p>
<p>For <code>cats.effect</code>, for the &quot;cancel&quot; action, what happens is that
whatever you specify in the <code>IO.cancelable</code> builder gets executed. And
depending on the implementation of an <code>IO.cancelable</code> task, it can
become non-terminating. If we'd need to describe our <code>cancel</code>
operation with an impure signature, it would be:</p>
<pre><code class="hljs css language-scala">() =&gt; <span class="hljs-type">Unit</span>
</code></pre>
<p>By comparison Haskell (and possibly the upcoming Scalaz 8 <code>IO</code>), sends
an error, a <code>Throwable</code> on interruption and canceled tasks get
completed with that <code>Throwable</code>. Their impure cancel is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Throwable</span> =&gt; <span class="hljs-type">Unit</span>
</code></pre>
<p><code>Throwable =&gt; Unit</code> allows the task's logic to know the cancellation
reason, however cancellation is about cutting the connection to the
producer, closing all resources as soon as possible, because you're no
longer interested in the result, due to some race condition that
happened.</p>
<p><code>Throwable =&gt; Unit</code> is also a little confusing, being too broad in
scope. Users might be tricked into sending messages back to the
producer via this channel, in order to steer it, to change its
outcome - however cancellation is cancellation, we're doing it for the
purpose of releasing resources and the implementation of race
conditions will end up closing the connection, disallowing the
canceled task to send anything downstream.</p>
<p>Therefore it's confusing for the user and the only practical use is to
release resources differently, based on the received error. But that's
not a use-case that's worth pursuing, given the increase in
complexity.</p>
<h2><a class="anchor" aria-hidden="true" id="safe-resource-acquisition-and-release"></a><a href="#safe-resource-acquisition-and-release" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Safe Resource Acquisition and Release</h2>
<h3><a class="anchor" aria-hidden="true" id="status-quo"></a><a href="#status-quo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Status Quo</h3>
<p>In mainstream imperative languages you usually have <code>try / finally</code>
statements at disposal for acquisition and safe release of resources.
Pattern goes like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">javaReadFirstLine</span></span>(file: <span class="hljs-type">File</span>): <span class="hljs-type">String</span> = {
  <span class="hljs-keyword">val</span> in = <span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(file))
  <span class="hljs-keyword">try</span> {
    in.readLine()
  } <span class="hljs-keyword">finally</span> {
    in.close()
  }
}
</code></pre>
<p>It does have problems like:</p>
<ol>
<li>this statement is obviously meant for side-effectful computations
and can't be used by FP abstractions</li>
<li>it's only meant for synchronous execution, so we can't use it
when working with abstractions capable of asynchrony
(e.g. <code>IO</code>, <code>Task</code>, <code>Future</code>)</li>
<li><code>finally</code> executes regardless of the exception type,
indiscriminately, so if you get an out of memory error it still
tries to close the file handle, unnecessarily delaying a process
crash</li>
<li>if the body of <code>try</code> throws an exception, then followed by
the body of <code>finally</code> also throwing an exception, then the
exception of <code>finally</code> gets rethrown, hiding the original problem</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="bracket"></a><a href="#bracket" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bracket</h3>
<p>Via the <code>bracket</code> operation we can easily describe the above:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFirstLine</span></span>(file: <span class="hljs-type">File</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(file))).bracket { in =&gt;
    <span class="hljs-comment">// Usage (the try block)</span>
    <span class="hljs-type">IO</span>(in.readLine())
  } { in =&gt;
    <span class="hljs-comment">// Releasing the reader (the finally block)</span>
    <span class="hljs-type">IO</span>(in.close()).void
  }
</code></pre>
<p>Notes:</p>
<ol>
<li>this is pure, so it can be used for FP</li>
<li>this works with asynchronous <code>IO</code> actions</li>
<li>the <code>release</code> action will happen regardless of the exit status
of the <code>use</code> action, so it will execute for successful completion,
for thrown errors or for canceled execution</li>
<li>if the <code>use</code> action throws an error and then the <code>release</code> action
throws an error as well, the reported error will be that of
<code>use</code>, whereas the error thrown by <code>release</code> will just get logged
(via <code>System.err</code>)</li>
</ol>
<p>Of special consideration is that <code>bracket</code> calls the <code>release</code> action
on cancellation as well. Consider this sample:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFile</span></span>(file: <span class="hljs-type">File</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>] = {
  <span class="hljs-comment">// Opens file with an asynchronous boundary before it, </span>
  <span class="hljs-comment">// ensuring that processing doesn't block the "current thread"</span>
  <span class="hljs-keyword">val</span> acquire = <span class="hljs-type">IO</span>.shift *&gt; <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(file)))
    
  acquire.bracket { in =&gt;
    <span class="hljs-comment">// Usage (the try block)</span>
    <span class="hljs-type">IO</span> {
      <span class="hljs-comment">// Ugly, low-level Java code warning!</span>
      <span class="hljs-keyword">val</span> content = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>()
      <span class="hljs-keyword">var</span> line: <span class="hljs-type">String</span> = <span class="hljs-literal">null</span>
      do {
        line = in.readLine()
        <span class="hljs-keyword">if</span> (line != <span class="hljs-literal">null</span>) content.append(line)
      } <span class="hljs-keyword">while</span> (line != <span class="hljs-literal">null</span>)
      content.toString()
    }
  } { in =&gt;
    <span class="hljs-comment">// Releasing the reader (the finally block)</span>
    <span class="hljs-comment">// This is problematic if the resulting `IO` can get </span>
    <span class="hljs-comment">// canceled, because it can lead to data corruption</span>
    <span class="hljs-type">IO</span>(in.close()).void
  }
}
</code></pre>
<p>That loop can be slow, we could be talking about a big file and
as described in the &quot;<em>Concurrency and Cancellation</em>&quot; section,
cancellation is a concurrent action with whatever goes on in <code>use</code>.</p>
<p>And in this case, on top of the JVM that is capable of multi-threading,
calling <code>io.close()</code> concurrently with that loop
can lead to data corruption. Depending on use-case synchronization
might be needed to prevent it:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io._

<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFile</span></span>(file: <span class="hljs-type">File</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>] = {
  <span class="hljs-comment">// Opens file with an asynchronous boundary before it, </span>
  <span class="hljs-comment">// ensuring that processing doesn't block the "current thread"</span>
  <span class="hljs-keyword">val</span> acquire = <span class="hljs-type">IO</span>.shift *&gt; <span class="hljs-type">IO</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(file)))
    
  <span class="hljs-comment">// Suspended execution because we are going to mutate </span>
  <span class="hljs-comment">// a shared variable</span>
  <span class="hljs-type">IO</span>.suspend {
    <span class="hljs-comment">// Shared state meant to signal cancellation</span>
    <span class="hljs-keyword">var</span> isCanceled = <span class="hljs-literal">false</span>
    
    acquire.bracket { in =&gt;
      <span class="hljs-type">IO</span> {
        <span class="hljs-keyword">val</span> content = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>()
        <span class="hljs-keyword">var</span> line: <span class="hljs-type">String</span> = <span class="hljs-literal">null</span>
        do {
        <span class="hljs-comment">// Synchronized access to isCanceled and to the reader</span>
          line = in.synchronized {
            <span class="hljs-keyword">if</span> (!isCanceled)
              in.readLine()
            <span class="hljs-keyword">else</span>
              <span class="hljs-literal">null</span>
          }
          <span class="hljs-keyword">if</span> (line != <span class="hljs-literal">null</span>) content.append(line)
        } <span class="hljs-keyword">while</span> (line != <span class="hljs-literal">null</span>)
        content.toString()
      }
    } { in =&gt;
      <span class="hljs-type">IO</span> {
        <span class="hljs-comment">// Synchronized access to isCanceled and to the reader</span>
        in.synchronized {
          isCanceled = <span class="hljs-literal">true</span>
          in.close()
        }
      }.void
    }
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="bracketcase"></a><a href="#bracketcase" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bracketCase</h3>
<p>The <code>bracketCase</code> operation is the generalized <code>bracket</code>, also receiving
an <code>ExitCase</code> in <code>release</code> in order to distinguish between:</p>
<ol>
<li>successful completion</li>
<li>completion in error</li>
<li>cancellation</li>
</ol>
<p>Usage sample:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">BufferedReader</span>
<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">ExitCase</span>.{<span class="hljs-type">Completed</span>, <span class="hljs-type">Error</span>, <span class="hljs-type">Canceled</span>}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readLine</span></span>(in: <span class="hljs-type">BufferedReader</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">String</span>] =
  <span class="hljs-type">IO</span>.pure(in).bracketCase { in =&gt;
    <span class="hljs-type">IO</span>(in.readLine())
  } { 
    <span class="hljs-keyword">case</span> (_, <span class="hljs-type">Completed</span> | <span class="hljs-type">Error</span>(_)) =&gt;
      <span class="hljs-comment">// Do nothing</span>
      <span class="hljs-type">IO</span>.unit
    <span class="hljs-keyword">case</span> (in, <span class="hljs-type">Canceled</span>) =&gt;
      <span class="hljs-type">IO</span>(in.close())
  }
</code></pre>
<p>In this example we are only closing the passed resource in case
cancellation occurred. As to why we're doing this — consider that
the <code>BufferedReader</code> reference was given to us and usually the
producer of such a resource should also be in charge of releasing
it. If this function would release the given <code>BufferedReader</code> on
a successful result, then this would be a flawed implementation.</p>
<p>Remember the age old C++ idiom of &quot;<em>resource acquisition is
initialization (RAII)</em>&quot;, which says that the lifetime of a resource
should be tied to the lifetime of its parent.</p>
<p>But in case we detect cancellation, we might want to close that
resource, because in the case of a cancellation event, we might
not have a &quot;run-loop&quot; active after this <code>IO</code> returns its result,
so there might not be anybody available to release it.</p>
<h2><a class="anchor" aria-hidden="true" id="conversions"></a><a href="#conversions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conversions</h2>
<p>There are two useful operations defined in the <code>IO</code> companion object to lift both a scala <code>Future</code> and an <code>Either</code> into <code>IO</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="fromfuture"></a><a href="#fromfuture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>fromFuture</h3>
<p>Constructs an <code>IO</code> which evaluates the given <code>Future</code> and produces either a result or a failure. It is defined as follow:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromFuture</span></span>[<span class="hljs-type">A</span>](iof: <span class="hljs-type">IO</span>[<span class="hljs-type">Future</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = ???
</code></pre>
<p>Because <code>Future</code> eagerly evaluates, as well as because it memoizes, this function takes its parameter as an <code>IO</code>, which could be lazily evaluated. If this laziness is appropriately threaded back to the definition site of the <code>Future</code>, it ensures that the computation is fully managed by <code>IO</code> and thus referentially transparent.</p>
<p>Lazy evaluation, equivalent with by-name parameters:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-type">IO</span>.fromFuture(<span class="hljs-type">IO</span> {
  <span class="hljs-type">Future</span>(println(<span class="hljs-string">"I come from the Future!"</span>))
})
</code></pre>
<p>Eager evaluation:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> f = <span class="hljs-type">Future</span>.successful(<span class="hljs-string">"I come from the Future!"</span>)

<span class="hljs-type">IO</span>.fromFuture(<span class="hljs-type">IO</span>.pure(f))
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fromeither"></a><a href="#fromeither" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>fromEither</h3>
<p>Lifts an <code>Either[Throwable, A]</code> into the <code>IO[A]</code> context raising the throwable if it exists.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromEither</span></span>[<span class="hljs-type">A</span>](e: <span class="hljs-type">Either</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = e.fold(<span class="hljs-type">IO</span>.raiseError, <span class="hljs-type">IO</span>.pure)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="error-handling"></a><a href="#error-handling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error Handling</h2>
<p>Since there is an instance of <code>MonadError[IO, Throwable]</code> available in Cats Effect, all the error handling is done through it. This means you can use all the operations available for <code>MonadError</code> and thus for <code>ApplicativeError</code> on <code>IO</code> as long as the error type is a <code>Throwable</code>. Operations such as <code>raiseError</code>, <code>attempt</code>, <code>handleErrorWith</code>, <code>recoverWith</code>, etc. Just make sure you have the syntax import in scope such as <code>cats.implicits._</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="raiseerror"></a><a href="#raiseerror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>raiseError</h3>
<p>Constructs an <code>IO</code> which sequences the specified exception.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">val</span> boom: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"boom"</span>))
boom.unsafeRunSync()
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="attempt"></a><a href="#attempt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>attempt</h3>
<p>Materializes any sequenced exceptions into value space, where they may be handled. This is analogous to the <code>catch</code> clause in <code>try</code>/<code>catch</code>, being the inverse of <code>IO.raiseError</code>. Example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-keyword">val</span> boom: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] = <span class="hljs-type">IO</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"boom"</span>))
boom.attempt.unsafeRunSync()
</code></pre>
<p>Look at the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/MonadError.scala">MonadError</a> typeclass for more.</p>
<h3><a class="anchor" aria-hidden="true" id="example-retrying-with-exponential-backoff"></a><a href="#example-retrying-with-exponential-backoff" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: Retrying with Exponential Backoff</h3>
<p>With <code>IO</code> you can easily model a loop that retries evaluation until success or some other condition is met.</p>
<p>For example here's a way to implement retries with exponential back-off:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">IO</span>, <span class="hljs-type">Timer</span>}

<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retryWithBackoff</span></span>[<span class="hljs-type">A</span>](ioa: <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>], initialDelay: <span class="hljs-type">FiniteDuration</span>, maxRetries: <span class="hljs-type">Int</span>)
  (<span class="hljs-keyword">implicit</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = {

  ioa.handleErrorWith { error =&gt;
    <span class="hljs-keyword">if</span> (maxRetries &gt; <span class="hljs-number">0</span>)
      <span class="hljs-type">IO</span>.sleep(initialDelay) *&gt; retryWithBackoff(ioa, initialDelay * <span class="hljs-number">2</span>, maxRetries - <span class="hljs-number">1</span>)
    <span class="hljs-keyword">else</span>
      <span class="hljs-type">IO</span>.raiseError(error)
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="thread-shifting"></a><a href="#thread-shifting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Thread Shifting</h2>
<p><code>IO</code> provides a function <code>shift</code> to give you more control over the execution of your operations.</p>
<h3><a class="anchor" aria-hidden="true" id="shift"></a><a href="#shift" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>shift</h3>
<p>Note there are 2 overloads of the <code>IO.shift</code> function:</p>
<ul>
<li>One that takes a <a href="/cats-effect/docs/datatypes/contextshift">ContextShift</a> that manages the thread-pool used to trigger async boundaries.</li>
<li>Another that takes a Scala <code>ExecutionContext</code> as the thread-pool.</li>
</ul>
<p>Please use the former by default and use the latter only for fine-grained control over the thread pool in use.</p>
<p>By default, <code>Cats Effect</code> can provide instance of <code>ContextShift[IO]</code> that manages thread-pools,
but only if there's an <code>ExecutionContext</code> in scope or if <a href="/cats-effect/docs/datatypes/ioapp">IOApp</a> is used:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>.global

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(global)
</code></pre>
<p>We can introduce an asynchronous boundary in the <code>flatMap</code> chain before a certain task:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> task = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"task"</span>))

<span class="hljs-type">IO</span>.shift(contextShift).flatMap(_ =&gt; task)
</code></pre>
<p>Note that the <code>ContextShift</code> value is taken implicitly from the context so you can just do this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.shift.flatMap(_ =&gt; task)
</code></pre>
<p>Or using <code>Cats</code> syntax:</p>
<pre><code class="hljs css language-scala">
<span class="hljs-type">IO</span>.shift *&gt; task
<span class="hljs-comment">// equivalent to</span>
implicitly[<span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]].shift *&gt; task
</code></pre>
<p>Or we can specify an asynchronous boundary &quot;after&quot; the evaluation of a certain task:</p>
<pre><code class="hljs css language-scala">task.flatMap(a =&gt; <span class="hljs-type">IO</span>.shift.map(_ =&gt; a))
</code></pre>
<p>Or using <code>Cats</code> syntax:</p>
<pre><code class="hljs css language-scala">task &lt;* <span class="hljs-type">IO</span>.shift
<span class="hljs-comment">// equivalent to</span>
task &lt;* implicitly[<span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>]].shift
</code></pre>
<p>Example of where this might be useful:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">Executors</span>

<span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">val</span> cachedThreadPool = <span class="hljs-type">Executors</span>.newCachedThreadPool()
<span class="hljs-keyword">val</span> <span class="hljs-type">BlockingFileIO</span>   = <span class="hljs-type">ExecutionContext</span>.fromExecutor(cachedThreadPool)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> <span class="hljs-type">Main</span> = <span class="hljs-type">ExecutionContext</span>.global

<span class="hljs-keyword">val</span> ioa: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-keyword">for</span> {
    _     &lt;- <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Enter your name: "</span>))
    _     &lt;- <span class="hljs-type">IO</span>.shift(<span class="hljs-type">BlockingFileIO</span>)
    name  &lt;- <span class="hljs-type">IO</span>(scala.io.<span class="hljs-type">StdIn</span>.readLine())
    _     &lt;- <span class="hljs-type">IO</span>.shift(<span class="hljs-type">Main</span>)
    _     &lt;- <span class="hljs-type">IO</span>(println(<span class="hljs-string">s"Welcome <span class="hljs-subst">$name</span>!"</span>))
    _     &lt;- <span class="hljs-type">IO</span>(cachedThreadPool.shutdown())
  } <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>We start by asking the user to enter its name and next we thread-shift to the <code>BlockingFileIO</code> execution context because we expect the following action to block on the thread for a long time and we don't want that to happen in the main thread of execution. After the <code>expensive IO operation</code> (readLine) gets back with a response we thread-shift back to the main execution context defined as an implicit value, and finally the program ends by showing a message in the console and shutting down a thread pool, all actions run in the main execution context.</p>
<p>Another somewhat less common application of <code>shift</code> is to reset the thread stack and yield control back to the underlying pool. For example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> doStuff = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"stuff"</span>))

<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> repeat: <span class="hljs-type">IO</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-keyword">for</span> {
    _ &lt;- doStuff
    _ &lt;- <span class="hljs-type">IO</span>.shift
    _ &lt;- repeat
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>In this example, <code>repeat</code> is a very long running <code>IO</code> (infinite, in fact!) which will just hog the underlying thread resource for as long as it continues running.  This can be a bit of a problem, and so we inject the <code>IO.shift</code> which yields control back to the underlying thread pool, giving it a chance to reschedule things and provide better fairness. This shifting also &quot;bounces&quot; the thread stack, popping all the way back to the thread pool and effectively trampolining the remainder of the computation. Although the thread-shifting is not completely necessary, it might help in some cases to alleviate the use of the main thread pool.</p>
<p>Thus, this function has four important use cases:</p>
<ul>
<li>Shifting blocking actions off of the main compute pool.</li>
<li>Defensively re-shifting asynchronous continuations back to the main compute pool.</li>
<li>Yielding control to some underlying pool for fairness reasons.</li>
<li>Preventing an overflow of the call stack in the case of improperly constructed <code>async</code> actions.</li>
</ul>
<p><code>IO</code> is trampolined for all <code>synchronous</code> and <code>asynchronous</code> joins. This means that you can safely call <code>flatMap</code> in a recursive function of arbitrary depth, without fear of blowing the stack. So you can do this for example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.<span class="hljs-type">IO</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signal</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">IO</span>.async(_(<span class="hljs-type">Right</span>(a)))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">Int</span>] =
  signal(n).flatMap { x =&gt;
    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) loop(n - <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> <span class="hljs-type">IO</span>.pure(<span class="hljs-number">0</span>)
  }
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="parallelism"></a><a href="#parallelism" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parallelism</h2>
<p>Since the introduction of the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala">Parallel</a> typeclasss in the Cats library and its <code>IO</code> instance, it became possible to execute two or more given <code>IO</code>s in parallel.</p>
<p>Note: all parallel operations require an implicit <code>ContextShift[IO]</code> in scope
(see <a href="/cats-effect/docs/datatypes/contextshift">ContextShift</a>). You have a <code>ContextShift</code> in scope if:</p>
<ol>
<li>via usage of <a href="/cats-effect/docs/datatypes/ioapp">IOApp</a> that gives you a <code>ContextShift</code> by default</li>
<li>the user provides a custom <code>ContextShift</code>, which can be created using <code>IO.contextShift(executionContext)</code></li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="parmapn"></a><a href="#parmapn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>parMapN</h3>
<p>It has the potential to run an arbitrary number of <code>IO</code>s in parallel, and it allows you to apply a function to the result (as in <code>map</code>). It finishes processing when all the <code>IO</code>s are completed, either successfully or with a failure. For example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> ioA = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running ioA"</span>))
<span class="hljs-keyword">val</span> ioB = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running ioB"</span>))
<span class="hljs-keyword">val</span> ioC = <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running ioC"</span>))

<span class="hljs-comment">// make sure that you have an implicit ContextShift[IO] in scope. </span>
<span class="hljs-keyword">val</span> program = (ioA, ioB, ioC).parMapN { (_, _, _) =&gt; () }

program.unsafeRunSync()
<span class="hljs-comment">//=&gt; Running ioB</span>
<span class="hljs-comment">//=&gt; Running ioC</span>
<span class="hljs-comment">//=&gt; Running ioA</span>
()
</code></pre>
<p>If any of the <code>IO</code>s completes with a failure then the result of the whole computation will be failed, while the unfinished tasks get cancelled. Example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">ExitCase</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> a = <span class="hljs-type">IO</span>.raiseError[<span class="hljs-type">Unit</span>](<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"boom"</span>)) &lt;* <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running ioA"</span>))
<span class="hljs-keyword">val</span> b = (<span class="hljs-type">IO</span>.sleep(<span class="hljs-number">1.</span>second) *&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Running ioB"</span>)))
  .guaranteeCase {
    <span class="hljs-keyword">case</span> <span class="hljs-type">ExitCase</span>.<span class="hljs-type">Canceled</span> =&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"ioB was canceled!"</span>))
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">IO</span>.unit
  }

<span class="hljs-keyword">val</span> parFailure = (a, b).parMapN { (_, _) =&gt; () }

parFailure.attempt.unsafeRunSync()
<span class="hljs-comment">//=&gt; ioB was canceled!</span>
<span class="hljs-comment">//=&gt; java.lang.Exception: boom</span>
<span class="hljs-comment">//=&gt;  ... 43 elided</span>
()
</code></pre>
<p>If one of the tasks fails immediately, then the other gets canceled and the computation completes immediately, so in this example the pairing via <code>parMapN</code> will not wait for 10 seconds before emitting the error:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>
<span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> contextShift: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> ioA = <span class="hljs-type">IO</span>.sleep(<span class="hljs-number">10.</span>seconds) *&gt; <span class="hljs-type">IO</span>(println(<span class="hljs-string">"Delayed!"</span>))
<span class="hljs-keyword">val</span> ioB = <span class="hljs-type">IO</span>.raiseError[<span class="hljs-type">Unit</span>](<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"dummy"</span>))

(ioA, ioB).parMapN((_, _) =&gt; ())
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="parsequence"></a><a href="#parsequence" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>parSequence</h3>
<p>If you have a list of IO, and you want a single IO with the result list you can use <code>parSequence</code> which executes the IO tasks in parallel.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">NonEmptyList</span>
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> cats.syntax.parallel._

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span> 

<span class="hljs-comment">// Needed for IO.start to do a logical thread fork</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> anIO = <span class="hljs-type">IO</span>(<span class="hljs-number">1</span>)

<span class="hljs-keyword">val</span> aLotOfIOs = 
  <span class="hljs-type">NonEmptyList</span>.of(anIO, anIO)

<span class="hljs-keyword">val</span> ioOfList = aLotOfIOs.parSequence
</code></pre>
<p>There is also <code>cats.Traverse.sequence</code> which does this synchronously.</p>
<h3><a class="anchor" aria-hidden="true" id="partraverse"></a><a href="#partraverse" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>parTraverse</h3>
<p>If you have a list of data and a way of turning each item into an IO, but you want a single IO for the results you can use <code>parTraverse</code> to run the steps in parallel.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">NonEmptyList</span>
<span class="hljs-keyword">import</span> cats.effect.{<span class="hljs-type">ContextShift</span>, <span class="hljs-type">Timer</span>, <span class="hljs-type">IO</span>}
<span class="hljs-keyword">import</span> cats.syntax.parallel._

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span> 

<span class="hljs-comment">// Needed for IO.start to do a logical thread fork</span>
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> cs: <span class="hljs-type">ContextShift</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.contextShift(<span class="hljs-type">ExecutionContext</span>.global)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> timer: <span class="hljs-type">Timer</span>[<span class="hljs-type">IO</span>] = <span class="hljs-type">IO</span>.timer(<span class="hljs-type">ExecutionContext</span>.global)

<span class="hljs-keyword">val</span> results = <span class="hljs-type">NonEmptyList</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parTraverse { i =&gt;
  <span class="hljs-type">IO</span>(i)
}
</code></pre>
<p>There is also <code>cats.Traverse.traverse</code> which will run each step synchronously.</p>
<h2><a class="anchor" aria-hidden="true" id="unsafe-operations"></a><a href="#unsafe-operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>&quot;Unsafe&quot; Operations</h2>
<p>We have been using some &quot;unsafe&quot; operations pretty much everywhere in the previous examples but we never explained any of them, so here it goes. All of the operations prefixed with <code>unsafe</code> are impure functions and perform side effects (for example Haskell has <code>unsafePerformIO</code>). But don't be scared by the name! You should write your programs in a monadic way using functions such as <code>map</code> and <code>flatMap</code> to compose other functions and ideally you should just call one of these unsafe operations only <strong>once</strong>, at the very end of your program.</p>
<h3><a class="anchor" aria-hidden="true" id="unsaferunsync"></a><a href="#unsaferunsync" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>unsafeRunSync</h3>
<p>Produces the result by running the encapsulated effects as impure side effects.</p>
<p>If any component of the computation is asynchronous, the current thread will block awaiting the results of the async computation. On JavaScript, an exception will be thrown instead to avoid generating a deadlock. By default, this blocking will be unbounded. To limit the thread block to some fixed time, use <code>unsafeRunTimed</code> instead.</p>
<p>Any exceptions raised within the effect will be re-thrown during evaluation.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>(println(<span class="hljs-string">"Sync!"</span>)).unsafeRunSync()
<span class="hljs-comment">// Sync!</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="unsaferunasync"></a><a href="#unsaferunasync" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>unsafeRunAsync</h3>
<p>Passes the result of the encapsulated effects to the given callback by running them as impure side effects.</p>
<p>Any exceptions raised within the effect will be passed to the callback in the <code>Either</code>. The callback will be invoked at most <em>once</em>. Note that it is very possible to construct an <code>IO</code> which never returns while still never blocking a thread, and attempting to evaluate that <code>IO</code> with this method will result in a situation where the callback is <em>never</em> invoked.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>(println(<span class="hljs-string">"Async!"</span>)).unsafeRunAsync(_ =&gt; ())
<span class="hljs-comment">// Async!</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="unsaferuncancelable"></a><a href="#unsaferuncancelable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>unsafeRunCancelable</h3>
<p>Evaluates the source <code>IO</code>, passing the result of the encapsulated effects to the given callback. Note that this has the potential to be interrupted.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>(println(<span class="hljs-string">"Potentially cancelable!"</span>)).unsafeRunCancelable(_ =&gt; ())
<span class="hljs-comment">// Potentially cancelable!</span>
<span class="hljs-comment">// res59: cats.effect.package.CancelToken[IO] = Suspend(</span>
<span class="hljs-comment">//   thunk = cats.effect.internals.IOConnection$Impl$$Lambda$10032/1883650790@692778d0</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="unsaferuntimed"></a><a href="#unsaferuntimed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>unsafeRunTimed</h3>
<p>Similar to <code>unsafeRunSync</code>, except with a bounded blocking duration when awaiting asynchronous results.</p>
<p>Please note that the <code>limit</code> parameter does not limit the time of the total computation, but rather acts as an upper bound on any <em>individual</em> asynchronous block.  Thus, if you pass a limit of <code>5 seconds</code> to an <code>IO</code> consisting solely of synchronous actions, the evaluation may take considerably longer than 5 seconds!</p>
<p>Furthermore, if you pass a limit of <code>5 seconds</code> to an <code>IO</code> consisting of several asynchronous actions joined together, evaluation may take up to <code>n * 5 seconds</code>, where <code>n</code> is the number of joined async actions.</p>
<p>As soon as an async blocking limit is hit, evaluation &quot;immediately&quot; aborts and <code>None</code> is returned.</p>
<p>Please note that this function is intended for <strong>testing</strong> purposes; it should never appear in your mainline production code!  It is absolutely not an appropriate function to use if you want to implement timeouts, or anything similar. If you need that sort of functionality, you should be using a streaming library (like <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> or <a href="https://monix.io/">Monix</a>).</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.duration._

<span class="hljs-type">IO</span>(println(<span class="hljs-string">"Timed!"</span>)).unsafeRunTimed(<span class="hljs-number">5.</span>seconds)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="unsafetofuture"></a><a href="#unsafetofuture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>unsafeToFuture</h3>
<p>Evaluates the effect and produces the result in a <code>Future</code>.</p>
<p>This is similar to <code>unsafeRunAsync</code> in that it evaluates the <code>IO</code> as a side effect in a non-blocking fashion, but uses a <code>Future</code> rather than an explicit callback.  This function should really only be used if interoperating with legacy code which uses Scala futures.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>(<span class="hljs-string">"Gimme a Future!"</span>).unsafeToFuture()
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="best-practices"></a><a href="#best-practices" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Best Practices</h2>
<p>This section presents some best practices for working with <code>IO</code>:</p>
<h3><a class="anchor" aria-hidden="true" id="keep-granularity"></a><a href="#keep-granularity" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Keep Granularity</h3>
<p>It's better to keep the granularity, so please don't do something like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span> {
  readingFile
  writingToDatabase
  sendBytesOverTcp
  launchMissiles
}
</code></pre>
<p>In FP we embrace reasoning about our programs and since <code>IO</code> is a <code>Monad</code> you can compose bigger programs from small ones in a <code>for-comprehension</code>.
For example:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> program =
  <span class="hljs-keyword">for</span> {
    data &lt;- readFile
    _    &lt;- writeToDatabase(data)
    _    &lt;- sendBytesOverTcp(data)
    _    &lt;- launchMissiles
  } <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>Each step of the comprehension is a small program, and the resulting <code>program</code> is a composition of all those small steps,
which is compositional with other programs. <code>IO</code> values compose.</p>
<h3><a class="anchor" aria-hidden="true" id="use-pure-functions-in-map--flatmap"></a><a href="#use-pure-functions-in-map--flatmap" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use pure functions in map / flatMap</h3>
<p>When using <code>map</code> or <code>flatMap</code> it is not recommended to pass a side effectful function, as mapping functions should also be pure.
So this should be avoided:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.pure(<span class="hljs-number">123</span>).map(n =&gt; println(<span class="hljs-string">s"NOT RECOMMENDED! <span class="hljs-subst">$n</span>"</span>))
</code></pre>
<p>This too should be avoided, because the side effect is not suspended in the returned <code>IO</code> value:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.pure(<span class="hljs-number">123</span>).flatMap { n =&gt;
  println(<span class="hljs-string">s"NOT RECOMMENDED! <span class="hljs-subst">$n</span>"</span>)
  <span class="hljs-type">IO</span>.unit
}
</code></pre>
<p>The correct approach would be this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">IO</span>.pure(<span class="hljs-number">123</span>).flatMap { n =&gt;
  <span class="hljs-comment">// Properly suspending the side effect</span>
  <span class="hljs-type">IO</span>(println(<span class="hljs-string">s"RECOMMENDED! <span class="hljs-subst">$n</span>"</span>))
}
</code></pre>
<p>Note that as far as the actual behavior of <code>IO</code> is concerned, something like <code>IO.pure(x).map(f)</code> is equivalent with <code>IO(f(x))</code> and <code>IO.pure(x).flatMap(f)</code> is equivalent with <code>IO.suspend(f(x))</code>.</p>
<p>But you should not rely on this behavior, because it is NOT described by the laws required by the <code>Sync</code> type class and those laws are the only guarantees of behavior that you get. For example the above equivalence might be broken in the future in regards to error handling. So this behavior is currently there for safety reasons, but you should regard it as an implementation detail that could change in the future.</p>
<p>Stick with pure functions.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/cats-effect/docs/guides/tracing"><span class="arrow-prev">← </span><span>Tracing</span></a><a class="docs-next button" href="/cats-effect/docs/datatypes/syncio"><span class="function-name-prevnext">SyncIO</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a><ul class="toc-headings"><li><a href="#on-referential-transparency-and-lazy-evaluation">On Referential Transparency and Lazy Evaluation</a></li><li><a href="#stack-safety">Stack Safety</a></li></ul></li><li><a href="#describing-effects">Describing Effects</a><ul class="toc-headings"><li><a href="#pure-values--iopure--iounit">Pure Values — IO.pure &amp; IO.unit</a></li><li><a href="#synchronous-effects--ioapply">Synchronous Effects — IO.apply</a></li><li><a href="#asynchronous-effects--ioasync--iocancelable">Asynchronous Effects — IO.async &amp; IO.cancelable</a></li><li><a href="#deferred-execution--iosuspend">Deferred Execution — IO.suspend</a></li></ul></li><li><a href="#concurrency-and-cancellation">Concurrency and Cancellation</a><ul class="toc-headings"><li><a href="#building-cancelable-io-tasks">Building cancelable IO tasks</a></li><li><a href="#concurrent-start--cancel">Concurrent start + cancel</a></li><li><a href="#runcancelable--unsaferuncancelable">runCancelable &amp; unsafeRunCancelable</a></li><li><a href="#uncancelable-marker">uncancelable marker</a></li><li><a href="#iocancelboundary">IO.cancelBoundary</a></li><li><a href="#race-conditions--race--racepair">Race Conditions — race &amp; racePair</a></li><li><a href="#comparison-with-haskells-async-interruption">Comparison with Haskell's &quot;async interruption&quot;</a></li></ul></li><li><a href="#safe-resource-acquisition-and-release">Safe Resource Acquisition and Release</a><ul class="toc-headings"><li><a href="#status-quo">Status Quo</a></li><li><a href="#bracket">bracket</a></li><li><a href="#bracketcase">bracketCase</a></li></ul></li><li><a href="#conversions">Conversions</a><ul class="toc-headings"><li><a href="#fromfuture">fromFuture</a></li><li><a href="#fromeither">fromEither</a></li></ul></li><li><a href="#error-handling">Error Handling</a><ul class="toc-headings"><li><a href="#raiseerror">raiseError</a></li><li><a href="#attempt">attempt</a></li><li><a href="#example-retrying-with-exponential-backoff">Example: Retrying with Exponential Backoff</a></li></ul></li><li><a href="#thread-shifting">Thread Shifting</a><ul class="toc-headings"><li><a href="#shift">shift</a></li></ul></li><li><a href="#parallelism">Parallelism</a><ul class="toc-headings"><li><a href="#parmapn">parMapN</a></li><li><a href="#parsequence">parSequence</a></li><li><a href="#partraverse">parTraverse</a></li></ul></li><li><a href="#unsafe-operations">&quot;Unsafe&quot; Operations</a><ul class="toc-headings"><li><a href="#unsaferunsync">unsafeRunSync</a></li><li><a href="#unsaferunasync">unsafeRunAsync</a></li><li><a href="#unsaferuncancelable">unsafeRunCancelable</a></li><li><a href="#unsaferuntimed">unsafeRunTimed</a></li><li><a href="#unsafetofuture">unsafeToFuture</a></li></ul></li><li><a href="#best-practices">Best Practices</a><ul class="toc-headings"><li><a href="#keep-granularity">Keep Granularity</a></li><li><a href="#use-pure-functions-in-map--flatmap">Use pure functions in map / flatMap</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/cats-effect/" class="nav-home"><img src="/cats-effect/img/favicon.png" alt="Cats Effect" width="66" height="58"/></a><div><h5>Docs</h5><a href="/cats-effect/docs/en/installation">Getting Started</a></div><div><h5>Community</h5><a href="https://typelevel.org/blog/">Blog</a><a href="https://gitter.im/typelevel/cats-effect">Gitter</a></div><div><h5>More</h5><a class="github-button" href="https://github.com/typelevel/cats-effect" data-icon="octicon-star" data-count-href="/typelevel/cats-effect/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/typelevel" class="twitter-follow-button">Follow @typelevel</a></div></div></section><section class="copyright">Copyright (c) 2017-2020 Typelevel</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>