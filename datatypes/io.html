<!DOCTYPE html><html><head><title>Cats Effect: IO</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats Effect contributors" /><meta name="description" content="The IO Monad for Scala" /><meta name="og:image" content="/cats-effect/img/poster.png" /><meta name="image" property="og:image" content="/cats-effect/img/poster.png" /><meta name="og:title" content="Cats Effect: IO" /><meta name="title" property="og:title" content="Cats Effect: IO" /><meta name="og:site_name" content="Cats Effect" /><meta name="og:url" content="https://typelevel.org/cats-effect/" /><meta name="og:type" content="website" /><meta name="og:description" content="The IO Monad for Scala" /><link rel="icon" type="image/png" href="/cats-effect/img/favicon.png" /><meta name="twitter:title" content="Cats Effect: IO" /><meta name="twitter:image" content="/cats-effect/img/poster.png" /><meta name="twitter:description" content="The IO Monad for Scala" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:creator" content="@typelevel" /><link rel="icon" type="image/png" sizes="16x16" href="/cats-effect/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats-effect/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats-effect/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats-effect/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats-effect/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats-effect/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats-effect/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats-effect/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats-effect/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats-effect/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats-effect/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats-effect/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats-effect/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats-effect/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats-effect/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats-effect/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats-effect/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats-effect/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats-effect/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats-effect/img/favicon310x150.png" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats-effect/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats-effect/css/light-style.css" /><link rel="stylesheet" href="/cats-effect/css/toc.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><div id="sidebar-brand"><a href="/cats-effect/" class="brand"><div class="brand-wrapper"></div><span>Cats Effect</span></a><button id="main-toggle" class="sidebar-toggle"><span class="close"></span></button></div><div class="sidebar-nav"> <div class="sidebar-nav-item  open"><a href="/cats-effect/datatypes/" title="Data Types" class="drop-nested">Data Types</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/datatypes/io.html" title="IO" class="active">IO</a> <a href="/cats-effect/datatypes/syncio.html" title="SyncIO" class="">SyncIO</a> <a href="/cats-effect/datatypes/fiber.html" title="Fiber" class="">Fiber</a> <a href="/cats-effect/datatypes/resource.html" title="Resource" class="">Resource</a> <a href="/cats-effect/datatypes/clock.html" title="Clock" class="">Clock</a> <a href="/cats-effect/datatypes/contextshift.html" title="ContextShift" class="">ContextShift</a> <a href="/cats-effect/datatypes/timer.html" title="Timer" class="">Timer</a> <a href="/cats-effect/datatypes/ioapp.html" title="IOApp" class="">IOApp</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/concurrency/" title="Concurrency" class="drop-nested">Concurrency</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/concurrency/basics.html" title="Concurrency Basics" class="">Concurrency Basics</a> <a href="/cats-effect/concurrency/deferred.html" title="Deferred" class="">Deferred</a> <a href="/cats-effect/concurrency/mvar.html" title="MVar" class="">MVar</a> <a href="/cats-effect/concurrency/ref.html" title="Ref" class="">Ref</a> <a href="/cats-effect/concurrency/semaphore.html" title="Semaphore" class="">Semaphore</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/typeclasses/" title="Type Classes" class="drop-nested">Type Classes</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/cats-effect/typeclasses/bracket.html" title="Bracket" class="">Bracket</a> <a href="/cats-effect/typeclasses/sync.html" title="Sync" class="">Sync</a> <a href="/cats-effect/typeclasses/liftio.html" title="LiftIO" class="">LiftIO</a> <a href="/cats-effect/typeclasses/async.html" title="Async" class="">Async</a> <a href="/cats-effect/typeclasses/concurrent.html" title="Concurrent" class="">Concurrent</a> <a href="/cats-effect/typeclasses/effect.html" title="Effect" class="">Effect</a> <a href="/cats-effect/typeclasses/concurrent-effect.html" title="ConcurrentEffect" class="">ConcurrentEffect</a></div></div> <div class="sidebar-nav-item  "><a href="/cats-effect/tutorial/tutorial.html" title="Tutorial" class="">Tutorial</a></div> <div class="sidebar-nav-item  "><a href="/cats-effect/tracing/" title="Tracing" class="">Tracing</a></div> <div class="sidebar-nav-item  "><a href="/cats-effect/testing/" title="Testing" class="">Testing</a></div></div></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-effect" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats-effect"><div class="content-wrapper"><section><h1>IO</h1>

<p>A data type for encoding side effects as pure values, capable of
expressing both synchronous and asynchronous computations.</p>

<nav role="navigation" id="toc"></nav>

<h2 id="introduction">Introduction</h2>

<p>A value of type <code class="language-plaintext highlighter-rouge">IO[A]</code> is a computation which, when evaluated, can
perform effects before returning a value of type <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p><code class="language-plaintext highlighter-rouge">IO</code> values are pure, immutable values and thus preserves referential
transparency, being usable in functional programming. An <code class="language-plaintext highlighter-rouge">IO</code> is a
data structure that represents just a description of a side effectful
computation.</p>

<p><code class="language-plaintext highlighter-rouge">IO</code> can describe synchronous or asynchronous computations that:</p>

<ol>
  <li>on evaluation yield exactly one result</li>
  <li>can end in either success or failure and in case of failure
<code class="language-plaintext highlighter-rouge">flatMap</code> chains get short-circuited (<code class="language-plaintext highlighter-rouge">IO</code> implementing the algebra
of <code class="language-plaintext highlighter-rouge">MonadError</code>)</li>
  <li>can be canceled, but note this capability relies on the
user to provide cancellation logic</li>
</ol>

<p>Effects described via this abstraction are not evaluated until the
“end of the world”, which is to say, when one of the “unsafe” methods
are used. Effectful results are not memoized, meaning that memory
overhead is minimal (and no leaks), and also that a single effect may
be run multiple times in a referentially-transparent manner. For
example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="nv">ioa</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"hey!"</span><span class="o">)</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">program</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
     <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">ioa</span>
     <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">ioa</span>
  <span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>

<span class="nv">program</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; hey!</span>
<span class="c1">//=&gt; hey!</span>
<span class="o">()</span>
</code></pre></div></div>

<p>The above example prints “hey!” twice, as the effect re-runs each time
it is sequenced in the monadic chain.</p>

<h3 id="on-referential-transparency-and-lazy-evaluation">On Referential Transparency and Lazy Evaluation</h3>

<p><code class="language-plaintext highlighter-rouge">IO</code> can suspend side effects and is thus a lazily evaluated data type, being many times compared with <code class="language-plaintext highlighter-rouge">Future</code> from the standard library and to understand the landscape in terms of the evaluation model (in Scala), consider this classification:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Eager</th>
      <th style="text-align: center">Lazy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="https://typelevel.org/cats/datatypes/eval.html">Eval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">() =&gt; (A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">IO[A]</td>
    </tr>
  </tbody>
</table>

<p>In comparison with Scala’s <code class="language-plaintext highlighter-rouge">Future</code>, the <code class="language-plaintext highlighter-rouge">IO</code> data type preserves <em>referential transparency</em> even when dealing with side effects and is lazily evaluated. In an eager language like Scala, this is the difference between a result and the function producing it.</p>

<p>Similar with <code class="language-plaintext highlighter-rouge">Future</code>, with <code class="language-plaintext highlighter-rouge">IO</code> you can reason about the results of asynchronous processes, but due to its purity and laziness <code class="language-plaintext highlighter-rouge">IO</code> can be thought of as a specification (to be evaluated at the “<em>end of the world</em>”), yielding more control over the evaluation model and being more predictable, for example when dealing with sequencing vs parallelism, when composing multiple IOs or when dealing with failure.</p>

<p>Note laziness goes hand in hand with referential transparency. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>If we have referential transparency, we can rewrite that example as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nf">addToGauge</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">task</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">task</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>This doesn’t work with <code class="language-plaintext highlighter-rouge">Future</code>, but works with <code class="language-plaintext highlighter-rouge">IO</code> and this ability is essential for <em>functional programming</em>.</p>

<h3 id="stack-safety">Stack Safety</h3>

<p><code class="language-plaintext highlighter-rouge">IO</code> is trampolined in its <code class="language-plaintext highlighter-rouge">flatMap</code> evaluation. This means that you
can safely call <code class="language-plaintext highlighter-rouge">flatMap</code> in a recursive function of arbitrary depth,
without fear of blowing the stack:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> 
      <span class="nf">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span>
    <span class="k">else</span> 
      <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">IO</code> implements all the typeclasses shown in the <a href="/cats-effect/typeclasses/">hierarchy</a>. Therefore
all those operations are available for <code class="language-plaintext highlighter-rouge">IO</code>, in addition to some
others.</p>

<h2 id="describing-effects">Describing Effects</h2>

<p><code class="language-plaintext highlighter-rouge">IO</code> is a potent abstraction that can efficiently describe multiple
kinds of effects:</p>

<h3 id="pure-values--iopure--iounit">Pure Values — IO.pure &amp; IO.unit</h3>

<p>You can lift pure values into <code class="language-plaintext highlighter-rouge">IO</code>, yielding <code class="language-plaintext highlighter-rouge">IO</code> values that are
“already evaluated”, the following function being defined on IO’s 
companion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Note that the given parameter is passed by value, not by name.</p>

<p>For example we can lift a number (pure value) into <code class="language-plaintext highlighter-rouge">IO</code> and compose it
with another <code class="language-plaintext highlighter-rouge">IO</code> that wraps a side a effect in a safe manner, as
nothing is going to be executed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">25</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Number is: $n"</span><span class="o">)))</span>
</code></pre></div></div>

<p>It should be obvious that <code class="language-plaintext highlighter-rouge">IO.pure</code> cannot suspend side effects, because
<code class="language-plaintext highlighter-rouge">IO.pure</code> is eagerly evaluated, with the given parameter being passed
by value, so don’t do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"THIS IS WRONG!"</span><span class="o">))</span>
</code></pre></div></div>

<p>In this case the <code class="language-plaintext highlighter-rouge">println</code> will trigger a side effect that is not
suspended in <code class="language-plaintext highlighter-rouge">IO</code> and given this code that probably is not our
intention.</p>

<p><code class="language-plaintext highlighter-rouge">IO.unit</code> is simply an alias for <code class="language-plaintext highlighter-rouge">IO.pure(())</code>, being a reusable
reference that you can use when an <code class="language-plaintext highlighter-rouge">IO[Unit]</code> value is required, but
you don’t need to trigger any other side effects:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">unit</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(())</span>
</code></pre></div></div>

<p>Given <code class="language-plaintext highlighter-rouge">IO[Unit]</code> is so prevalent in Scala code, the <code class="language-plaintext highlighter-rouge">Unit</code> type itself
being meant to signal completion of side effectful routines, this
proves useful as a shortcut and as an optimization, since the same
reference is returned.</p>

<h3 id="synchronous-effects--ioapply">Synchronous Effects — IO.apply</h3>

<p>It’s probably the most used builder and the equivalent of
<code class="language-plaintext highlighter-rouge">Sync[IO].delay</code>, describing <code class="language-plaintext highlighter-rouge">IO</code> operations that can be evaluated
immediately, on the current thread and call-stack:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Note the given parameter is passed ‘‘by name’’, its execution being
“suspended” in the <code class="language-plaintext highlighter-rouge">IO</code> context.</p>

<p>An example would be reading / writing from / to the console, which on
top of the JVM uses blocking I/O, so their execution is immediate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">readLn</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">StdIn</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span>
</code></pre></div></div>

<p>And then we can use that to model interactions with the console in a
purely functional way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"What's your name?"</span><span class="o">)</span>
  <span class="n">n</span> <span class="k">&lt;-</span> <span class="n">readLn</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">s</span><span class="s">"Hello, $n!"</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<h3 id="asynchronous-effects--ioasync--iocancelable">Asynchronous Effects — IO.async &amp; IO.cancelable</h3>

<p><code class="language-plaintext highlighter-rouge">IO</code> can describe asynchronous processes via the <code class="language-plaintext highlighter-rouge">IO.async</code> and
<code class="language-plaintext highlighter-rouge">IO.cancelable</code> builders.</p>

<p><code class="language-plaintext highlighter-rouge">IO.async</code> is the operation that complies with the laws of
<code class="language-plaintext highlighter-rouge">Async#async</code> (see <a href="/cats-effect/typeclasses/async.html">Async</a>) and can
describe simple asynchronous processes that cannot be canceled,
its signature being:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">async</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="o">(</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>The provided registration function injects a callback that you can use
to signal either successful results (with <code class="language-plaintext highlighter-rouge">Right(a)</code>), or failures
(with <code class="language-plaintext highlighter-rouge">Left(error)</code>). Users can trigger whatever asynchronous side
effects are required, then use the injected callback to signal
completion.</p>

<p>For example, you don’t need to convert Scala’s <code class="language-plaintext highlighter-rouge">Future</code>, because you
already have a conversion operation defined in <code class="language-plaintext highlighter-rouge">IO.fromFuture</code>,
however the code for converting a <code class="language-plaintext highlighter-rouge">Future</code> would be straightforward:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">Future</span><span class="o">,</span> <span class="nc">ExecutionContext</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">convert</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="c1">// This triggers evaluation of the by-name param and of onComplete, </span>
    <span class="c1">// so it's OK to have side effects in this callback</span>
    <span class="nv">fa</span><span class="o">.</span><span class="py">onComplete</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h4 id="cancelable-processes">Cancelable Processes</h4>

<p>For building cancelable <code class="language-plaintext highlighter-rouge">IO</code> tasks you need to use the
<code class="language-plaintext highlighter-rouge">IO.cancelable</code> builder, this being compliant with
<code class="language-plaintext highlighter-rouge">Concurrent#cancelable</code> (see <a href="/cats-effect/typeclasses/concurrent.html">Concurrent</a>) 
and has this signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cancelable</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="o">(</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>So it is similar with <code class="language-plaintext highlighter-rouge">IO.async</code>, but in that registration function
the user is expected to provide an <code class="language-plaintext highlighter-rouge">IO[Unit]</code> that captures the
required cancellation logic.</p>

<p>Important: cancellation is the ability to interrupt an <code class="language-plaintext highlighter-rouge">IO</code> task before
completion, possibly releasing any acquired resources, useful in race
conditions to prevent leaks.</p>

<p>As example suppose we want to describe a <code class="language-plaintext highlighter-rouge">sleep</code> operation that
depends on Java’s <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code>, delaying a tick for a
certain time duration:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.ScheduledExecutorService</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">delayedTick</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">sc</span><span class="k">:</span> <span class="kt">ScheduledExecutorService</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 
  <span class="nv">IO</span><span class="o">.</span><span class="py">cancelable</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span> <span class="o">}</span>
    <span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">schedule</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="nv">d</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="nv">d</span><span class="o">.</span><span class="py">unit</span><span class="o">)</span>
    
    <span class="c1">// Returning the cancellation token needed to cancel </span>
    <span class="c1">// the scheduling and release resources early</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">f</span><span class="o">.</span><span class="py">cancel</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="py">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note this delayed tick is already described by <code class="language-plaintext highlighter-rouge">IO.sleep</code> (via
<code class="language-plaintext highlighter-rouge">Timer</code>), so you don’t need to do it.</p>

<p>More on dealing with ‘‘cancellation’’ below.</p>

<h4 id="ionever">IO.never</h4>

<p><code class="language-plaintext highlighter-rouge">IO.never</code> represents a non-terminating <code class="language-plaintext highlighter-rouge">IO</code> defined in terms of
<code class="language-plaintext highlighter-rouge">async</code>, useful as shortcut and as a reusable reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">never</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">async</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
</code></pre></div></div>

<p>This is useful in order to use non-termination in certain cases, like
race conditions. For example, given <code class="language-plaintext highlighter-rouge">IO.race</code>, we have these
equivalences:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">race</span><span class="o">(</span><span class="n">lh</span><span class="o">,</span> <span class="nv">IO</span><span class="o">.</span><span class="py">never</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">lh</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="nv">IO</span><span class="o">.</span><span class="py">race</span><span class="o">(</span><span class="nv">IO</span><span class="o">.</span><span class="py">never</span><span class="o">,</span> <span class="n">rh</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">rh</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="deferred-execution--iosuspend">Deferred Execution — IO.suspend</h3>

<p>The <code class="language-plaintext highlighter-rouge">IO.suspend</code> builder has this equivalence:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">suspend</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="py">flatten</span>
</code></pre></div></div>

<p>So it is useful for suspending effects, but that defers the completion
of the returned <code class="language-plaintext highlighter-rouge">IO</code> to some other reference. It’s also useful for
modeling stack safe, tail recursive loops:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nf">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Normally a function like this would eventually yield a stack overflow
error on top of the JVM. By using <code class="language-plaintext highlighter-rouge">IO.suspend</code> and doing all of those
cycles using <code class="language-plaintext highlighter-rouge">IO</code>’s run-loop, its evaluation is lazy and it’s going to
use constant memory. This would work with <code class="language-plaintext highlighter-rouge">flatMap</code> as well, of
course, <code class="language-plaintext highlighter-rouge">suspend</code> being just nicer in this example.</p>

<p>We could describe this function using Scala’s <code class="language-plaintext highlighter-rouge">@tailrec</code> mechanism,
however by using <code class="language-plaintext highlighter-rouge">IO</code> we can also preserve fairness by inserting
asynchronous boundaries:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>

<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">next</span> <span class="k">=</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
      <span class="c1">// Every 100 cycles, introduce a logical thread fork</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nv">cs</span><span class="o">.</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="n">next</span>
      <span class="k">else</span>
        <span class="n">next</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And now we have something more interesting than a <code class="language-plaintext highlighter-rouge">@tailrec</code> loop. As
can be seen, <code class="language-plaintext highlighter-rouge">IO</code> allows very precise control over the evaluation.</p>

<h2 id="concurrency-and-cancellation">Concurrency and Cancellation</h2>

<p><code class="language-plaintext highlighter-rouge">IO</code> can describe interruptible asynchronous processes. As an
implementation detail:</p>

<ol>
  <li>not all <code class="language-plaintext highlighter-rouge">IO</code> tasks are cancelable. Cancellation status is only checked <em>after</em>
asynchronous boundaries. It can be achieved in the following way:
    <ul>
      <li>Building it with <code class="language-plaintext highlighter-rouge">IO.cancelable</code>, <code class="language-plaintext highlighter-rouge">IO.async</code>, <code class="language-plaintext highlighter-rouge">IO.asyncF</code> or <code class="language-plaintext highlighter-rouge">IO.bracket</code></li>
      <li>Using <code class="language-plaintext highlighter-rouge">IO.cancelBoundary</code> or <code class="language-plaintext highlighter-rouge">IO.shift</code></li>
    </ul>
  </li>
</ol>

<p>Note that the second point is the consequence of the first one and anything that involves
  those operations is also possible to cancel. It includes, but is not limited to
  waiting on <code class="language-plaintext highlighter-rouge">Mvar.take</code>, <code class="language-plaintext highlighter-rouge">Mvar.put</code> and <code class="language-plaintext highlighter-rouge">Deferred.get</code>.</p>

<p>We should also note that <code class="language-plaintext highlighter-rouge">flatMap</code> chains are only cancelable only if
  the chain happens <em>after</em> an asynchronous boundary.
  After an asynchronous boundary, cancellation checks are performed on every N <code class="language-plaintext highlighter-rouge">flatMap</code>.
  The value of <code class="language-plaintext highlighter-rouge">N</code> is hardcoded to 512.</p>

<p>Here is an example,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">retryUntilRight</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">io</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">retryUntilRight</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// non-terminating IO that is NOT cancelable</span>
<span class="k">val</span> <span class="nv">notCancelable</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nf">retryUntilRight</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>

<span class="c1">// non-terminating IO that is cancelable because there is an</span>
<span class="c1">// async boundary created by IO.shift before `flatMap` chain</span>
<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="nf">retryUntilRight</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">IO</code> tasks that are cancelable, usually become non-terminating on
<code class="language-plaintext highlighter-rouge">cancel</code></li>
</ol>

<p>Also this might be a point of confusion for folks coming from Java and
that expect the features of <code class="language-plaintext highlighter-rouge">Thread.interrupt</code> or of the old and
deprecated <code class="language-plaintext highlighter-rouge">Thread.stop</code>:</p>

<p><code class="language-plaintext highlighter-rouge">IO</code> cancellation does NOT work like that, as thread interruption in
Java is inherently <em>unsafe, unreliable and not portable</em>!</p>

<p>Next subsections describe cancellation-related operations in more depth.</p>

<h3 id="building-cancelable-io-tasks">Building cancelable IO tasks</h3>

<p>Cancelable <code class="language-plaintext highlighter-rouge">IO</code> tasks can be described via the <code class="language-plaintext highlighter-rouge">IO.cancelable</code>
builder. The <code class="language-plaintext highlighter-rouge">delayedTick</code> example making use of the Java’s
<code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code> was already given above, but to recap:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.ScheduledExecutorService</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration.FiniteDuration</span>

<span class="k">def</span> <span class="nf">sleep</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">sc</span><span class="k">:</span> <span class="kt">ScheduledExecutorService</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">IO</span><span class="o">.</span><span class="py">cancelable</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span> 
    <span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span> <span class="o">}</span>
    <span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="nv">sc</span><span class="o">.</span><span class="py">schedule</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="nv">d</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="nv">d</span><span class="o">.</span><span class="py">unit</span><span class="o">)</span>
    <span class="c1">// Returning a function that can cancel our scheduling</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">f</span><span class="o">.</span><span class="py">cancel</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="py">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Important: if you don’t specify cancellation logic for a task, then the task
is NOT cancelable. So for example, using Java’s blocking I/O still:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="nf">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Freaking Java :-)</span>
  <span class="k">val</span> <span class="nv">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">),</span> <span class="s">"utf-8"</span><span class="o">))</span>
  
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// Uninterruptible loop</span>
    <span class="k">val</span> <span class="nv">sb</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
    <span class="k">var</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="nf">while</span> <span class="o">(</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">false</span>
      <span class="k">val</span> <span class="nv">line</span> <span class="k">=</span> <span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">()</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
        <span class="nv">sb</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="nv">sb</span><span class="o">.</span><span class="py">toString</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">async</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="nv">ec</span><span class="o">.</span><span class="py">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Signal completion</span>
        <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="nf">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">})</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This is obviously not cancelable and there’s no magic that the <code class="language-plaintext highlighter-rouge">IO</code>
implementation does to make that loop cancelable. No, we are not going
to use Java’s <code class="language-plaintext highlighter-rouge">Thread.interrupt</code>, because that would be unsafe and
unreliable and besides, whatever the <code class="language-plaintext highlighter-rouge">IO</code> does has to be portable
between platforms.</p>

<p>But there’s a lot of flexibility in what can be done, including here.
We could simply introduce a variable that changes to <code class="language-plaintext highlighter-rouge">false</code>, to be
observed in that <code class="language-plaintext highlighter-rouge">while</code> loop:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.File</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="nf">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">isActive</span><span class="k">:</span> <span class="kt">AtomicBoolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
  <span class="k">val</span> <span class="nv">linesIterator</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="py">getLines</span><span class="o">()</span>
  <span class="k">var</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="nf">while</span> <span class="o">(</span><span class="n">hasNext</span> <span class="o">&amp;&amp;</span> <span class="nv">isActive</span><span class="o">.</span><span class="py">get</span><span class="o">)</span> <span class="o">{</span>
    <span class="nv">sc</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="nv">linesIterator</span><span class="o">.</span><span class="py">next</span><span class="o">())</span>
    <span class="n">hasNext</span> <span class="k">=</span> <span class="nv">linesIterator</span><span class="o">.</span><span class="py">hasNext</span>
  <span class="o">}</span>
  <span class="nv">sc</span><span class="o">.</span><span class="py">toString</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">isActive</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    
    <span class="nv">ec</span><span class="o">.</span><span class="py">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Signal completion</span>
        <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="nf">unsafeFileToString</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">isActive</span><span class="o">)))</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">})</span>    
    <span class="c1">// On cancel, signal it</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">isActive</span><span class="o">.</span><span class="py">set</span><span class="o">(</span><span class="kc">false</span><span class="o">)).</span><span class="py">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<h4 id="gotcha-cancellation-is-a-concurrent-action">Gotcha: Cancellation is a Concurrent Action!</h4>

<p>This is not always obvious, not from the above examples, but you might
be tempted to do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>

<span class="k">def</span> <span class="nf">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="nv">ec</span><span class="o">.</span><span class="py">execute</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="nf">cb</span><span class="o">(</span>
      <span class="k">try</span> <span class="nc">Right</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span> 
      <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">}))</span>
      
    <span class="c1">// Cancellation logic is not thread-safe!</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()).</span><span class="py">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>An operation like this might be useful in streaming abstractions that
stream I/O chunks via <code class="language-plaintext highlighter-rouge">IO</code> (via libraries like FS2, Monix, or others).</p>

<p>But the described operation is incorrect, because <code class="language-plaintext highlighter-rouge">in.close()</code> is
<em>concurrent</em> with <code class="language-plaintext highlighter-rouge">in.readLine</code>, which can lead to thrown exceptions
and in many cases it can lead to data <em>corruption</em>. This is a big
no-no. We want to interrupt whatever it is that the <code class="language-plaintext highlighter-rouge">IO</code> is doing, but
not at the cost of data corruption.</p>

<p>Therefore the user needs to handle thread safety concerns. So here’s
one way of doing it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.AtomicBoolean</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.util.control.NonFatal</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">def</span> <span class="nf">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">cancelable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">isActive</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="nv">ec</span><span class="o">.</span><span class="py">execute</span> <span class="o">{</span> <span class="o">()</span> <span class="k">=&gt;</span> 
      <span class="nf">if</span> <span class="o">(</span><span class="nv">isActive</span><span class="o">.</span><span class="py">getAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">try</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">()))</span>
        <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">))</span> <span class="o">}</span>
      <span class="o">}</span>
      <span class="c1">// Note there's no else; if cancellation was executed</span>
      <span class="c1">// then we don't call the callback; task becoming </span>
      <span class="c1">// non-terminating ;-)</span>
    <span class="o">}</span>
    <span class="c1">// Cancellation logic</span>
    <span class="nc">IO</span> <span class="o">{</span>
      <span class="c1">// Thread-safe gate</span>
      <span class="nf">if</span> <span class="o">(</span><span class="nv">isActive</span><span class="o">.</span><span class="py">getAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
        <span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
    <span class="o">}.</span><span class="py">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In this example it is the cancellation logic itself that calls
<code class="language-plaintext highlighter-rouge">in.close()</code>, but the call is safe due to the thread-safe guard that
we’re creating by usage of an atomic <code class="language-plaintext highlighter-rouge">getAndSet</code>.</p>

<p>This is using an <code class="language-plaintext highlighter-rouge">AtomicBoolean</code> for thread-safety, but don’t shy away
from using intrinsic locks / mutexes via <code class="language-plaintext highlighter-rouge">synchronize</code> blocks or
whatever else concurrency primitives the JVM provides, whatever is
needed in these side effectful functions. And don’t worry, this is
usually needed only in <code class="language-plaintext highlighter-rouge">IO.cancelable</code>, <code class="language-plaintext highlighter-rouge">IO.async</code> or <code class="language-plaintext highlighter-rouge">IO.apply</code>, as
these builders represents the FFI for interacting with the impure
world, aka the dark side, otherwise once you’re in <code class="language-plaintext highlighter-rouge">IO</code>’s context, you
can compose concurrent tasks using higher level tools.</p>

<p>Shared memory concurrency is unfortunately both the blessing and the
curse of working with kernel threads. Not a big problem on N:1
platforms like JavaScript, but there you don’t get in-process CPU
parallelism either. Such is life, a big trail of tradeoffs.</p>

<h3 id="concurrent-start--cancel">Concurrent start + cancel</h3>

<p>You can use <code class="language-plaintext highlighter-rouge">IO</code> as a green-threads system, with the “fork” operation
being available via <code class="language-plaintext highlighter-rouge">IO#start</code>, the operation that’s compliant with
<code class="language-plaintext highlighter-rouge">Concurrent#start</code>. This is a method with the following signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">start</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">A</span><span class="o">]]</span>
</code></pre></div></div>

<p>Returned is a <a href="/cats-effect/datatypes/fiber.html">Fiber</a>. You can think of fibers as being
lightweight threads, a fiber being the pure and light equivalent of a
thread that can be either joined (via <code class="language-plaintext highlighter-rouge">join</code>) or interrupted (via
<code class="language-plaintext highlighter-rouge">cancel</code>).</p>

<p>Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="c1">// Needed for IO.start to do a logical thread fork</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">launchMissiles</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom!"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">runToBunker</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"To the bunker!!!"</span><span class="o">))</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">fiber</span> <span class="k">&lt;-</span> <span class="nv">launchMissiles</span><span class="o">.</span><span class="py">start</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">runToBunker</span><span class="o">.</span><span class="py">handleErrorWith</span> <span class="o">{</span> <span class="n">error</span> <span class="k">=&gt;</span>
    <span class="c1">// Retreat failed, cancel launch (maybe we should</span>
    <span class="c1">// have retreated to our bunker before the launch?)</span>
    <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span> <span class="o">*&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">aftermath</span> <span class="k">&lt;-</span> <span class="nv">fiber</span><span class="o">.</span><span class="py">join</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">aftermath</span>
</code></pre></div></div>

<p>Implementation notes:</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">*&gt;</code> operator is defined in Cats and you can treat it as an
alias for <code class="language-plaintext highlighter-rouge">lh.flatMap(_ =&gt; rh)</code></li>
</ul>

<h3 id="runcancelable--unsaferuncancelable">runCancelable &amp; unsafeRunCancelable</h3>

<p>The above is the pure <code class="language-plaintext highlighter-rouge">cancel</code>, accessible via <code class="language-plaintext highlighter-rouge">Fiber</code>. However the
second way to access cancellation token and thus interrupt tasks is via
<code class="language-plaintext highlighter-rouge">runCancelable</code> (the pure version) and <code class="language-plaintext highlighter-rouge">unsafeRunCancelable</code> (the
unsafe version).</p>

<p>Example relying on the side-effecting <code class="language-plaintext highlighter-rouge">unsafeRunCancelable</code> and note
this kind of code is impure and should be used with care:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Needed for `sleep`</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="c1">// Delayed println</span>
<span class="k">val</span> <span class="nv">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">cancel</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nv">io</span><span class="o">.</span><span class="py">unsafeRunCancelable</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Done: $r"</span><span class="o">))</span>

<span class="c1">// ... if a race condition happens, we can cancel it,</span>
<span class="c1">// thus canceling the scheduling of `IO.sleep`</span>
<span class="nv">cancel</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">runCancelable</code> alternative is the operation that’s compliant with
the laws of <a href="/cats-effect/typeclasses/concurrent-effect.html">ConcurrentEffect</a>.
Same idea, only the actual execution is suspended in <code class="language-plaintext highlighter-rouge">SyncIO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.SyncIO</span>
<span class="k">import</span> <span class="nn">cats.syntax.flatMap._</span>

<span class="k">val</span> <span class="nv">pureResult</span><span class="k">:</span> <span class="kt">SyncIO</span><span class="o">[</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">io</span><span class="o">.</span><span class="py">runCancelable</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span> 
  <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Done: $r"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// On evaluation, this will first execute the source, then it </span>
<span class="c1">// will cancel it, because it makes perfect sense :-)</span>
<span class="nv">pureResult</span><span class="o">.</span><span class="py">toIO</span><span class="o">.</span><span class="py">flatten</span>
</code></pre></div></div>

<h3 id="uncancelable-marker">uncancelable marker</h3>

<p>Given a cancelable <code class="language-plaintext highlighter-rouge">IO</code>, we can turn it into an <code class="language-plaintext highlighter-rouge">IO</code> that cannot be
canceled:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Needed for `sleep`</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="c1">// Our reference from above</span>
<span class="k">val</span> <span class="nv">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>

<span class="c1">// This IO can't be canceled, even if we try</span>
<span class="nv">io</span><span class="o">.</span><span class="py">uncancelable</span>
</code></pre></div></div>

<p>Sometimes you need to ensure that an <code class="language-plaintext highlighter-rouge">IO</code>’s execution is <em>atomic</em>, or
in other words, either all of it executes, or none of it. And this is
what this operation does — cancelable IOs are by definition not atomic
and in certain cases we need to make them atomic.</p>

<p>This law is compliant with the laws of <code class="language-plaintext highlighter-rouge">Concurrent#uncancelable</code> (see
<a href="/cats-effect/typeclasses/concurrent.html">Concurrent</a>).</p>

<h3 id="iocancelboundary">IO.cancelBoundary</h3>

<p>Returns a cancelable boundary — an <code class="language-plaintext highlighter-rouge">IO</code> task that checks for the
cancellation status of the run-loop and does not allow for the bind
continuation to keep executing in case cancellation happened.</p>

<p>This operation is very similar to <code class="language-plaintext highlighter-rouge">IO.shift</code>, as it can be dropped in
<code class="language-plaintext highlighter-rouge">flatMap</code> chains in order to make such long loops cancelable:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">next</span> <span class="k">=</span> <span class="nf">fib</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>

      <span class="c1">// Every 100-th cycle check cancellation status</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nv">IO</span><span class="o">.</span><span class="py">cancelBoundary</span> <span class="o">*&gt;</span> <span class="n">next</span>
      <span class="k">else</span>
        <span class="n">next</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>As mentioned at the very beginning of this section, fairness needs to be managed explicitly, 
the protocol being easy to follow and predictable in a WYSIWYG fashion.</p>

<h4 id="comparison-to-ioshift">Comparison to IO.shift</h4>

<p><code class="language-plaintext highlighter-rouge">IO.cancelBoundary</code> is essentially lighter version of <code class="language-plaintext highlighter-rouge">IO.shift</code> without 
ability to shift into different thread pool. It is lighter in the sense that
it will avoid doing logical fork.</p>

<h3 id="race-conditions--race--racepair">Race Conditions — race &amp; racePair</h3>

<p>A race condition is a piece of logic that creates a race between two
or more tasks, with the winner being signaled immediately, with the
losers being usually canceled.</p>

<p><code class="language-plaintext highlighter-rouge">IO</code> provides two operations for races in its companion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// simple version</span>
<span class="k">def</span> <span class="nf">race</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>
  
<span class="c1">// advanced version</span>
<span class="k">def</span> <span class="nf">racePair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">B</span><span class="o">])</span>, <span class="o">(</span><span class="kt">Fiber</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">B</span><span class="o">)]]</span>
</code></pre></div></div>

<p>The simple version, <code class="language-plaintext highlighter-rouge">IO.race</code>, will cancel the loser immediately,
whereas the second version gives you a <a href="/cats-effect/datatypes/fiber.html">Fiber</a>, letting
you decide what to do next.</p>

<p>So <code class="language-plaintext highlighter-rouge">race</code> can be derived with <code class="language-plaintext highlighter-rouge">racePair</code> like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">race</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">lh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">rh</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  
  <span class="nv">IO</span><span class="o">.</span><span class="py">racePair</span><span class="o">(</span><span class="n">lh</span><span class="o">,</span> <span class="n">rh</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fiber</span><span class="o">))</span> <span class="k">=&gt;</span> 
      <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">fiber</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> 
      <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">race</code> we could implement a “timeout” operation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.CancellationException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration.FiniteDuration</span>

<span class="k">def</span> <span class="nf">timeoutTo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">after</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">fallback</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">],</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">IO</span><span class="o">.</span><span class="py">race</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="nv">timer</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="n">after</span><span class="o">)).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fallback</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">timeout</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">after</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">],</span> <span class="n">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">error</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CancellationException</span><span class="o">(</span><span class="nv">after</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
  <span class="nf">timeoutTo</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">after</span><span class="o">,</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>See <em>Parallelism</em> section above for how to obtain a <code class="language-plaintext highlighter-rouge">Timer[IO]</code></p>

<h3 id="comparison-with-haskells-async-interruption">Comparison with Haskell’s “async interruption”</h3>

<p>Haskell treats interruption with what they call “asynchronous
exceptions”, providing the ability to interrupt a running task by 
throwing an exception from another thread (concurrently).</p>

<p>For <code class="language-plaintext highlighter-rouge">cats.effect</code>, for the “cancel” action, what happens is that
whatever you specify in the <code class="language-plaintext highlighter-rouge">IO.cancelable</code> builder gets executed. And
depending on the implementation of an <code class="language-plaintext highlighter-rouge">IO.cancelable</code> task, it can
become non-terminating. If we’d need to describe our <code class="language-plaintext highlighter-rouge">cancel</code>
operation with an impure signature, it would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</code></pre></div></div>

<p>By comparison Haskell (and possibly the upcoming Scalaz 8 <code class="language-plaintext highlighter-rouge">IO</code>), sends
an error, a <code class="language-plaintext highlighter-rouge">Throwable</code> on interruption and canceled tasks get
completed with that <code class="language-plaintext highlighter-rouge">Throwable</code>. Their impure cancel is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Throwable</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Throwable =&gt; Unit</code> allows the task’s logic to know the cancellation
reason, however cancellation is about cutting the connection to the
producer, closing all resources as soon as possible, because you’re no
longer interested in the result, due to some race condition that
happened.</p>

<p><code class="language-plaintext highlighter-rouge">Throwable =&gt; Unit</code> is also a little confusing, being too broad in
scope. Users might be tricked into sending messages back to the
producer via this channel, in order to steer it, to change its
outcome - however cancellation is cancellation, we’re doing it for the
purpose of releasing resources and the implementation of race
conditions will end up closing the connection, disallowing the
canceled task to send anything downstream.</p>

<p>Therefore it’s confusing for the user and the only practical use is to
release resources differently, based on the received error. But that’s
not a use-case that’s worth pursuing, given the increase in
complexity.</p>

<h2 id="safe-resource-acquisition-and-release">Safe Resource Acquisition and Release</h2>

<h3 id="status-quo">Status Quo</h3>

<p>In mainstream imperative languages you usually have <code class="language-plaintext highlighter-rouge">try / finally</code>
statements at disposal for acquisition and safe release of resources.
Pattern goes like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">def</span> <span class="nf">javaReadFirstLine</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">))</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">()</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It does have problems like:</p>

<ol>
  <li>this statement is obviously meant for side-effectful computations
and can’t be used by FP abstractions</li>
  <li>it’s only meant for synchronous execution, so we can’t use it
when working with abstractions capable of asynchrony
(e.g. <code class="language-plaintext highlighter-rouge">IO</code>, <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">Future</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">finally</code> executes regardless of the exception type,
indiscriminately, so if you get an out of memory error it still
tries to close the file handle, unnecessarily delaying a process
crash</li>
  <li>if the body of <code class="language-plaintext highlighter-rouge">try</code> throws an exception, then followed by
the body of <code class="language-plaintext highlighter-rouge">finally</code> also throwing an exception, then the
exception of <code class="language-plaintext highlighter-rouge">finally</code> gets rethrown, hiding the original problem</li>
</ol>

<h3 id="bracket">bracket</h3>

<p>Via the <code class="language-plaintext highlighter-rouge">bracket</code> operation we can easily describe the above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="nf">readFirstLine</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">))).</span><span class="py">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Usage (the try block)</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Releasing the reader (the finally block)</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()).</span><span class="py">void</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Notes:</p>

<ol>
  <li>this is pure, so it can be used for FP</li>
  <li>this works with asynchronous <code class="language-plaintext highlighter-rouge">IO</code> actions</li>
  <li>the <code class="language-plaintext highlighter-rouge">release</code> action will happen regardless of the exit status 
of the <code class="language-plaintext highlighter-rouge">use</code> action, so it will execute for successful completion,
for thrown errors or for canceled execution</li>
  <li>if the <code class="language-plaintext highlighter-rouge">use</code> action throws an error and then the <code class="language-plaintext highlighter-rouge">release</code> action
throws an error as well, the reported error will be that of
<code class="language-plaintext highlighter-rouge">use</code>, whereas the error thrown by <code class="language-plaintext highlighter-rouge">release</code> will just get logged
(via <code class="language-plaintext highlighter-rouge">System.err</code>)</li>
</ol>

<p>Of special consideration is that <code class="language-plaintext highlighter-rouge">bracket</code> calls the <code class="language-plaintext highlighter-rouge">release</code> action
on cancellation as well. Consider this sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Opens file with an asynchronous boundary before it, </span>
  <span class="c1">// ensuring that processing doesn't block the "current thread"</span>
  <span class="k">val</span> <span class="nv">acquire</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
    
  <span class="nv">acquire</span><span class="o">.</span><span class="py">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Usage (the try block)</span>
    <span class="nc">IO</span> <span class="o">{</span>
      <span class="c1">// Ugly, low-level Java code warning!</span>
      <span class="k">val</span> <span class="nv">content</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
      <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
      <span class="k">do</span> <span class="o">{</span>
        <span class="n">line</span> <span class="k">=</span> <span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">()</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="nv">content</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
      <span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="nv">content</span><span class="o">.</span><span class="py">toString</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="c1">// Releasing the reader (the finally block)</span>
    <span class="c1">// This is problematic if the resulting `IO` can get </span>
    <span class="c1">// canceled, because it can lead to data corruption</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()).</span><span class="py">void</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That loop can be slow, we could be talking about a big file and
as described in the “<em>Concurrency and Cancellation</em>” section,
cancellation is a concurrent action with whatever goes on in <code class="language-plaintext highlighter-rouge">use</code>.</p>

<p>And in this case, on top of the JVM that is capable of multi-threading, 
calling <code class="language-plaintext highlighter-rouge">io.close()</code> concurrently with that loop
can lead to data corruption. Depending on use-case synchronization
might be needed to prevent it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Opens file with an asynchronous boundary before it, </span>
  <span class="c1">// ensuring that processing doesn't block the "current thread"</span>
  <span class="k">val</span> <span class="nv">acquire</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">)))</span>
    
  <span class="c1">// Suspended execution because we are going to mutate </span>
  <span class="c1">// a shared variable</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
    <span class="c1">// Shared state meant to signal cancellation</span>
    <span class="k">var</span> <span class="n">isCanceled</span> <span class="k">=</span> <span class="kc">false</span>
    
    <span class="nv">acquire</span><span class="o">.</span><span class="py">bracket</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">content</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">()</span>
        <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">do</span> <span class="o">{</span>
        <span class="c1">// Synchronized access to isCanceled and to the reader</span>
          <span class="n">line</span> <span class="k">=</span> <span class="nv">in</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
            <span class="nf">if</span> <span class="o">(!</span><span class="n">isCanceled</span><span class="o">)</span>
              <span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">()</span>
            <span class="k">else</span>
              <span class="kc">null</span>
          <span class="o">}</span>
          <span class="nf">if</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="nv">content</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
        <span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="nv">content</span><span class="o">.</span><span class="py">toString</span><span class="o">()</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span> <span class="o">{</span>
        <span class="c1">// Synchronized access to isCanceled and to the reader</span>
        <span class="nv">in</span><span class="o">.</span><span class="py">synchronized</span> <span class="o">{</span>
          <span class="n">isCanceled</span> <span class="k">=</span> <span class="kc">true</span>
          <span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
        <span class="o">}</span>
      <span class="o">}.</span><span class="py">void</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="bracketcase">bracketCase</h3>

<p>The <code class="language-plaintext highlighter-rouge">bracketCase</code> operation is the generalized <code class="language-plaintext highlighter-rouge">bracket</code>, also receiving
an <code class="language-plaintext highlighter-rouge">ExitCase</code> in <code class="language-plaintext highlighter-rouge">release</code> in order to distinguish between:</p>

<ol>
  <li>successful completion</li>
  <li>completion in error</li>
  <li>cancellation</li>
</ol>

<p>Usage sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.BufferedReader</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">cats.effect.ExitCase.</span><span class="o">{</span><span class="nc">Completed</span><span class="o">,</span> <span class="nc">Error</span><span class="o">,</span> <span class="nc">Canceled</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">readLine</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">in</span><span class="o">).</span><span class="py">bracketCase</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span>
    <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span>
  <span class="o">}</span> <span class="o">{</span> 
    <span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Completed</span> <span class="o">|</span> <span class="nc">Error</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="c1">// Do nothing</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">unit</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="nc">Canceled</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">IO</span><span class="o">(</span><span class="nv">in</span><span class="o">.</span><span class="py">close</span><span class="o">())</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In this example we are only closing the passed resource in case
cancellation occurred. As to why we’re doing this — consider that 
the <code class="language-plaintext highlighter-rouge">BufferedReader</code> reference was given to us and usually the 
producer of such a resource should also be in charge of releasing 
it. If this function would release the given <code class="language-plaintext highlighter-rouge">BufferedReader</code> on
a successful result, then this would be a flawed implementation.</p>

<p>Remember the age old C++ idiom of “<em>resource acquisition is 
initialization (RAII)</em>”, which says that the lifetime of a resource
should be tied to the lifetime of its parent.</p>

<p>But in case we detect cancellation, we might want to close that 
resource, because in the case of a cancellation event, we might
not have a “run-loop” active after this <code class="language-plaintext highlighter-rouge">IO</code> returns its result,
so there might not be anybody available to release it.</p>

<h2 id="conversions">Conversions</h2>

<p>There are two useful operations defined in the <code class="language-plaintext highlighter-rouge">IO</code> companion object to lift both a scala <code class="language-plaintext highlighter-rouge">Future</code> and an <code class="language-plaintext highlighter-rouge">Either</code> into <code class="language-plaintext highlighter-rouge">IO</code>.</p>

<h3 id="fromfuture">fromFuture</h3>

<p>Constructs an <code class="language-plaintext highlighter-rouge">IO</code> which evaluates the given <code class="language-plaintext highlighter-rouge">Future</code> and produces either a result or a failure. It is defined as follow:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">def</span> <span class="nf">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">iof</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">Future</code> eagerly evaluates, as well as because it memoizes, this function takes its parameter as an <code class="language-plaintext highlighter-rouge">IO</code>, which could be lazily evaluated. If this laziness is appropriately threaded back to the definition site of the <code class="language-plaintext highlighter-rouge">Future</code>, it ensures that the computation is fully managed by <code class="language-plaintext highlighter-rouge">IO</code> and thus referentially transparent.</p>

<p>Lazy evaluation, equivalent with by-name parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">ExecutionContext.Implicits.global</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="nv">IO</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="nc">IO</span> <span class="o">{</span>
  <span class="nc">Future</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"I come from the Future!"</span><span class="o">))</span>
<span class="o">})</span>
</code></pre></div></div>

<p>Eager evaluation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">(</span><span class="s">"I come from the Future!"</span><span class="o">)</span>

<span class="nv">IO</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="fromeither">fromEither</h3>

<p>Lifts an <code class="language-plaintext highlighter-rouge">Either[Throwable, A]</code> into the <code class="language-plaintext highlighter-rouge">IO[A]</code> context raising the throwable if it exists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="nf">fromEither</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">e</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">,</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="error-handling">Error Handling</h2>

<p>Since there is an instance of <code class="language-plaintext highlighter-rouge">MonadError[IO, Throwable]</code> available in Cats Effect, all the error handling is done through it. This means you can use all the operations available for <code class="language-plaintext highlighter-rouge">MonadError</code> and thus for <code class="language-plaintext highlighter-rouge">ApplicativeError</code> on <code class="language-plaintext highlighter-rouge">IO</code> as long as the error type is a <code class="language-plaintext highlighter-rouge">Throwable</code>. Operations such as <code class="language-plaintext highlighter-rouge">raiseError</code>, <code class="language-plaintext highlighter-rouge">attempt</code>, <code class="language-plaintext highlighter-rouge">handleErrorWith</code>, <code class="language-plaintext highlighter-rouge">recoverWith</code>, etc. Just make sure you have the syntax import in scope such as <code class="language-plaintext highlighter-rouge">cats.syntax.all._</code>.</p>

<h3 id="raiseerror">raiseError</h3>

<p>Constructs an <code class="language-plaintext highlighter-rouge">IO</code> which sequences the specified exception.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="nv">boom</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span>
<span class="nv">boom</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="attempt">attempt</h3>

<p>Materializes any sequenced exceptions into value space, where they may be handled. This is analogous to the <code class="language-plaintext highlighter-rouge">catch</code> clause in <code class="language-plaintext highlighter-rouge">try</code>/<code class="language-plaintext highlighter-rouge">catch</code>, being the inverse of <code class="language-plaintext highlighter-rouge">IO.raiseError</code>. Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="nv">boom</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span>
<span class="nv">boom</span><span class="o">.</span><span class="py">attempt</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>Look at the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/MonadError.scala">MonadError</a> typeclass for more.</p>

<h3 id="example-retrying-with-exponential-backoff">Example: Retrying with Exponential Backoff</h3>

<p>With <code class="language-plaintext highlighter-rouge">IO</code> you can easily model a loop that retries evaluation until success or some other condition is met.</p>

<p>For example here’s a way to implement retries with exponential back-off:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">IO</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">retryWithBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">initialDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">ioa</span><span class="o">.</span><span class="py">handleErrorWith</span> <span class="o">{</span> <span class="n">error</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="n">initialDelay</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nf">retryWithBackoff</span><span class="o">(</span><span class="n">ioa</span><span class="o">,</span> <span class="n">initialDelay</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">maxRetries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="thread-shifting">Thread Shifting</h2>

<p><code class="language-plaintext highlighter-rouge">IO</code> provides a function <code class="language-plaintext highlighter-rouge">shift</code> to give you more control over the execution of your operations.</p>

<h3 id="shift">shift</h3>

<p>Note there are 2 overloads of the <code class="language-plaintext highlighter-rouge">IO.shift</code> function:</p>

<ul>
  <li>One that takes a <a href="/cats-effect/datatypes/contextshift.html">ContextShift</a> that manages the thread-pool used to trigger async boundaries.</li>
  <li>Another that takes a Scala <code class="language-plaintext highlighter-rouge">ExecutionContext</code> as the thread-pool.</li>
</ul>

<p>Please use the former by default and use the latter only for fine-grained control over the thread pool in use.</p>

<p>By default, <code class="language-plaintext highlighter-rouge">Cats Effect</code> can provide instance of <code class="language-plaintext highlighter-rouge">ContextShift[IO]</code> that manages thread-pools,
but only if there’s an <code class="language-plaintext highlighter-rouge">ExecutionContext</code> in scope or if <a href="/cats-effect/datatypes/ioapp.html">IOApp</a> is used:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="n">global</span><span class="o">)</span>
</code></pre></div></div>

<p>We can introduce an asynchronous boundary in the <code class="language-plaintext highlighter-rouge">flatMap</code> chain before a certain task:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"task"</span><span class="o">))</span>

<span class="nv">IO</span><span class="o">.</span><span class="py">shift</span><span class="o">(</span><span class="n">contextShift</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">)</span>
</code></pre></div></div>

<p>Note that the <code class="language-plaintext highlighter-rouge">ContextShift</code> value is taken implicitly from the context so you can just do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">shift</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">)</span>
</code></pre></div></div>

<p>Or using <code class="language-plaintext highlighter-rouge">Cats</code> syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">IO</span><span class="o">.</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="n">task</span>
<span class="c1">// equivalent to</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]].</span><span class="py">shift</span> <span class="o">*&gt;</span> <span class="n">task</span>
</code></pre></div></div>

<p>Or we can specify an asynchronous boundary “after” the evaluation of a certain task:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">task</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div></div>

<p>Or using <code class="language-plaintext highlighter-rouge">Cats</code> syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">task</span> <span class="o">&lt;*</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span>
<span class="c1">// equivalent to</span>
<span class="n">task</span> <span class="o">&lt;*</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]].</span><span class="py">shift</span>
</code></pre></div></div>

<p>Example of where this might be useful:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.Executors</span>

<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">val</span> <span class="nv">cachedThreadPool</span> <span class="k">=</span> <span class="nv">Executors</span><span class="o">.</span><span class="py">newCachedThreadPool</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">BlockingFileIO</span>   <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">fromExecutor</span><span class="o">(</span><span class="n">cachedThreadPool</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">Main</span> <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Enter your name: "</span><span class="o">))</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">)</span>
    <span class="n">name</span>  <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">StdIn</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Welcome $name!"</span><span class="o">))</span>
    <span class="k">_</span>     <span class="k">&lt;-</span> <span class="nc">IO</span><span class="o">(</span><span class="nv">cachedThreadPool</span><span class="o">.</span><span class="py">shutdown</span><span class="o">())</span>
  <span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>We start by asking the user to enter its name and next we thread-shift to the <code class="language-plaintext highlighter-rouge">BlockingFileIO</code> execution context because we expect the following action to block on the thread for a long time and we don’t want that to happen in the main thread of execution. After the <code class="language-plaintext highlighter-rouge">expensive IO operation</code> (readLine) gets back with a response we thread-shift back to the main execution context defined as an implicit value, and finally the program ends by showing a message in the console and shutting down a thread pool, all actions run in the main execution context.</p>

<p>Another somewhat less common application of <code class="language-plaintext highlighter-rouge">shift</code> is to reset the thread stack and yield control back to the underlying pool. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">doStuff</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"stuff"</span><span class="o">))</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="nv">repeat</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">doStuff</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">IO</span><span class="o">.</span><span class="py">shift</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">repeat</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">repeat</code> is a very long running <code class="language-plaintext highlighter-rouge">IO</code> (infinite, in fact!) which will just hog the underlying thread resource for as long as it continues running.  This can be a bit of a problem, and so we inject the <code class="language-plaintext highlighter-rouge">IO.shift</code> which yields control back to the underlying thread pool, giving it a chance to reschedule things and provide better fairness. This shifting also “bounces” the thread stack, popping all the way back to the thread pool and effectively trampolining the remainder of the computation. Although the thread-shifting is not completely necessary, it might help in some cases to alleviate the use of the main thread pool.</p>

<p>Thus, this function has four important use cases:</p>
<ul>
  <li>Shifting blocking actions off of the main compute pool.</li>
  <li>Defensively re-shifting asynchronous continuations back to the main compute pool.</li>
  <li>Yielding control to some underlying pool for fairness reasons.</li>
  <li>Preventing an overflow of the call stack in the case of improperly constructed <code class="language-plaintext highlighter-rouge">async</code> actions.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">IO</code> is trampolined for all <code class="language-plaintext highlighter-rouge">synchronous</code> and <code class="language-plaintext highlighter-rouge">asynchronous</code> joins. This means that you can safely call <code class="language-plaintext highlighter-rouge">flatMap</code> in a recursive function of arbitrary depth, without fear of blowing the stack. So you can do this for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">def</span> <span class="nf">signal</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">async</span><span class="o">(</span><span class="nf">_</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>

<span class="k">def</span> <span class="nf">loop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">signal</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">loop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">else</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="parallelism">Parallelism</h2>

<p>Since the introduction of the <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala">Parallel</a> typeclasss in the Cats library and its <code class="language-plaintext highlighter-rouge">IO</code> instance, it became possible to execute two or more given <code class="language-plaintext highlighter-rouge">IO</code>s in parallel.</p>

<p>Note: all parallel operations require an implicit <code class="language-plaintext highlighter-rouge">ContextShift[IO]</code> in scope
(see <a href="/cats-effect/datatypes/contextshift.html">ContextShift</a>). You have a <code class="language-plaintext highlighter-rouge">ContextShift</code> in scope if:</p>

<ol>
  <li>via usage of <a href="/cats-effect/datatypes/ioapp.html">IOApp</a> that gives you a <code class="language-plaintext highlighter-rouge">ContextShift</code> by default</li>
  <li>the user provides a custom <code class="language-plaintext highlighter-rouge">ContextShift</code>, which can be created using <code class="language-plaintext highlighter-rouge">IO.contextShift(executionContext)</code></li>
</ol>

<h3 id="parmapn">parMapN</h3>

<p>It has the potential to run an arbitrary number of <code class="language-plaintext highlighter-rouge">IO</code>s in parallel, and it allows you to apply a function to the result (as in <code class="language-plaintext highlighter-rouge">map</code>). It finishes processing when all the <code class="language-plaintext highlighter-rouge">IO</code>s are completed, either successfully or with a failure. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">ioA</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Running ioA"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">ioB</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Running ioB"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">ioC</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Running ioC"</span><span class="o">))</span>

<span class="c1">// make sure that you have an implicit ContextShift[IO] in scope. </span>
<span class="k">val</span> <span class="nv">program</span> <span class="k">=</span> <span class="o">(</span><span class="n">ioA</span><span class="o">,</span> <span class="n">ioB</span><span class="o">,</span> <span class="n">ioC</span><span class="o">).</span><span class="py">parMapN</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>

<span class="nv">program</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; Running ioB</span>
<span class="c1">//=&gt; Running ioC</span>
<span class="c1">//=&gt; Running ioA</span>
<span class="o">()</span>
</code></pre></div></div>

<p>If any of the <code class="language-plaintext highlighter-rouge">IO</code>s completes with a failure then the result of the whole computation will be failed, while the unfinished tasks get cancelled. Example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">ExitCase</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Unit</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span> <span class="o">&lt;*</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Running ioA"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="o">(</span><span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Running ioB"</span><span class="o">)))</span>
  <span class="o">.</span><span class="py">guaranteeCase</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Canceled</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"ioB was canceled!"</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">unit</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="nv">parFailure</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">).</span><span class="py">parMapN</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>

<span class="nv">parFailure</span><span class="o">.</span><span class="py">attempt</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">//=&gt; ioB was canceled!</span>
<span class="c1">//=&gt; java.lang.Exception: boom</span>
<span class="c1">//=&gt;  ... 43 elided</span>
<span class="o">()</span>
</code></pre></div></div>

<p>If one of the tasks fails immediately, then the other gets canceled and the computation completes immediately, so in this example the pairing via <code class="language-plaintext highlighter-rouge">parMapN</code> will not wait for 10 seconds before emitting the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">ioA</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Delayed!"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">ioB</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Unit</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">))</span>

<span class="o">(</span><span class="n">ioA</span><span class="o">,</span> <span class="n">ioB</span><span class="o">).</span><span class="py">parMapN</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">())</span>
</code></pre></div></div>

<h3 id="parsequence">parSequence</h3>

<p>If you have a list of IO, and you want a single IO with the result list you can use <code class="language-plaintext highlighter-rouge">parSequence</code> which executes the IO tasks in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.parallel._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span> 

<span class="c1">// Needed for IO.start to do a logical thread fork</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">anIO</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">aLotOfIOs</span> <span class="k">=</span> 
  <span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="n">anIO</span><span class="o">,</span> <span class="n">anIO</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">ioOfList</span> <span class="k">=</span> <span class="nv">aLotOfIOs</span><span class="o">.</span><span class="py">parSequence</span>
</code></pre></div></div>

<p>There is also <code class="language-plaintext highlighter-rouge">cats.Traverse.sequence</code> which does this synchronously.</p>

<h3 id="partraverse">parTraverse</h3>

<p>If you have a list of data and a way of turning each item into an IO, but you want a single IO for the results you can use <code class="language-plaintext highlighter-rouge">parTraverse</code> to run the steps in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">ContextShift</span><span class="o">,</span> <span class="nc">Timer</span><span class="o">,</span> <span class="nc">IO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.syntax.parallel._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext</span> 

<span class="c1">// Needed for IO.start to do a logical thread fork</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">cs</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">contextShift</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">timer</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">results</span> <span class="k">=</span> <span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">parTraverse</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nc">IO</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There is also <code class="language-plaintext highlighter-rouge">cats.Traverse.traverse</code> which will run each step synchronously.</p>

<h2 id="unsafe-operations">“Unsafe” Operations</h2>

<p>We have been using some “unsafe” operations pretty much everywhere in the previous examples but we never explained any of them, so here it goes. All of the operations prefixed with <code class="language-plaintext highlighter-rouge">unsafe</code> are impure functions and perform side effects (for example Haskell has <code class="language-plaintext highlighter-rouge">unsafePerformIO</code>). But don’t be scared by the name! You should write your programs in a monadic way using functions such as <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> to compose other functions and ideally you should just call one of these unsafe operations only <strong>once</strong>, at the very end of your program.</p>

<h3 id="unsaferunsync">unsafeRunSync</h3>

<p>Produces the result by running the encapsulated effects as impure side effects.</p>

<p>If any component of the computation is asynchronous, the current thread will block awaiting the results of the async computation. On JavaScript, an exception will be thrown instead to avoid generating a deadlock. By default, this blocking will be unbounded. To limit the thread block to some fixed time, use <code class="language-plaintext highlighter-rouge">unsafeRunTimed</code> instead.</p>

<p>Any exceptions raised within the effect will be re-thrown during evaluation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Sync!"</span><span class="o">)).</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// Sync!</span>
</code></pre></div></div>

<h3 id="unsaferunasync">unsafeRunAsync</h3>

<p>Passes the result of the encapsulated effects to the given callback by running them as impure side effects.</p>

<p>Any exceptions raised within the effect will be passed to the callback in the <code class="language-plaintext highlighter-rouge">Either</code>. The callback will be invoked at most <em>once</em>. Note that it is very possible to construct an <code class="language-plaintext highlighter-rouge">IO</code> which never returns while still never blocking a thread, and attempting to evaluate that <code class="language-plaintext highlighter-rouge">IO</code> with this method will result in a situation where the callback is <em>never</em> invoked.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Async!"</span><span class="o">)).</span><span class="py">unsafeRunAsync</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
<span class="c1">// Async!</span>
</code></pre></div></div>

<h3 id="unsaferuncancelable">unsafeRunCancelable</h3>

<p>Evaluates the source <code class="language-plaintext highlighter-rouge">IO</code>, passing the result of the encapsulated effects to the given callback. Note that this has the potential to be interrupted.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Potentially cancelable!"</span><span class="o">)).</span><span class="py">unsafeRunCancelable</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
<span class="c1">// Potentially cancelable!</span>
<span class="c1">// res59: cats.effect.package.CancelToken[IO] = Suspend(</span>
<span class="c1">//   thunk = cats.effect.internals.IOConnection$Impl$$Lambda$10116/0x0000000802bdf040@54042796</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="unsaferuntimed">unsafeRunTimed</h3>

<p>Similar to <code class="language-plaintext highlighter-rouge">unsafeRunSync</code>, except with a bounded blocking duration when awaiting asynchronous results.</p>

<p>Please note that the <code class="language-plaintext highlighter-rouge">limit</code> parameter does not limit the time of the total computation, but rather acts as an upper bound on any <em>individual</em> asynchronous block.  Thus, if you pass a limit of <code class="language-plaintext highlighter-rouge">5 seconds</code> to an <code class="language-plaintext highlighter-rouge">IO</code> consisting solely of synchronous actions, the evaluation may take considerably longer than 5 seconds!</p>

<p>Furthermore, if you pass a limit of <code class="language-plaintext highlighter-rouge">5 seconds</code> to an <code class="language-plaintext highlighter-rouge">IO</code> consisting of several asynchronous actions joined together, evaluation may take up to <code class="language-plaintext highlighter-rouge">n * 5 seconds</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the number of joined async actions.</p>

<p>As soon as an async blocking limit is hit, evaluation “immediately” aborts and <code class="language-plaintext highlighter-rouge">None</code> is returned.</p>

<p>Please note that this function is intended for <strong>testing</strong> purposes; it should never appear in your mainline production code!  It is absolutely not an appropriate function to use if you want to implement timeouts, or anything similar. If you need that sort of functionality, you should be using a streaming library (like <a href="https://fs2.io/">fs2</a> or <a href="https://monix.io/">Monix</a>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Timed!"</span><span class="o">)).</span><span class="py">unsafeRunTimed</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="unsafetofuture">unsafeToFuture</h3>

<p>Evaluates the effect and produces the result in a <code class="language-plaintext highlighter-rouge">Future</code>.</p>

<p>This is similar to <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code> in that it evaluates the <code class="language-plaintext highlighter-rouge">IO</code> as a side effect in a non-blocking fashion, but uses a <code class="language-plaintext highlighter-rouge">Future</code> rather than an explicit callback.  This function should really only be used if interoperating with legacy code which uses Scala futures.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span><span class="o">(</span><span class="s">"Gimme a Future!"</span><span class="o">).</span><span class="py">unsafeToFuture</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="best-practices">Best Practices</h2>

<p>This section presents some best practices for working with <code class="language-plaintext highlighter-rouge">IO</code>:</p>

<h3 id="keep-granularity">Keep Granularity</h3>

<p>It’s better to keep the granularity, so please don’t do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IO</span> <span class="o">{</span>
  <span class="n">readingFile</span>
  <span class="n">writingToDatabase</span>
  <span class="n">sendBytesOverTcp</span>
  <span class="n">launchMissiles</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In FP we embrace reasoning about our programs and since <code class="language-plaintext highlighter-rouge">IO</code> is a <code class="language-plaintext highlighter-rouge">Monad</code> you can compose bigger programs from small ones in a <code class="language-plaintext highlighter-rouge">for-comprehension</code>.
For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">program</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">data</span> <span class="k">&lt;-</span> <span class="n">readFile</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="nf">writeToDatabase</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="nf">sendBytesOverTcp</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
    <span class="k">_</span>    <span class="k">&lt;-</span> <span class="n">launchMissiles</span>
  <span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Each step of the comprehension is a small program, and the resulting <code class="language-plaintext highlighter-rouge">program</code> is a composition of all those small steps,
which is compositional with other programs. <code class="language-plaintext highlighter-rouge">IO</code> values compose.</p>

<h3 id="use-pure-functions-in-map--flatmap">Use pure functions in map / flatMap</h3>

<p>When using <code class="language-plaintext highlighter-rouge">map</code> or <code class="language-plaintext highlighter-rouge">flatMap</code> it is not recommended to pass a side effectful function, as mapping functions should also be pure.
So this should be avoided:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"NOT RECOMMENDED! $n"</span><span class="o">))</span>
</code></pre></div></div>

<p>This too should be avoided, because the side effect is not suspended in the returned <code class="language-plaintext highlighter-rouge">IO</code> value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"NOT RECOMMENDED! $n"</span><span class="o">)</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The correct approach would be this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
  <span class="c1">// Properly suspending the side effect</span>
  <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"RECOMMENDED! $n"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that as far as the actual behavior of <code class="language-plaintext highlighter-rouge">IO</code> is concerned, something like <code class="language-plaintext highlighter-rouge">IO.pure(x).map(f)</code> is equivalent with <code class="language-plaintext highlighter-rouge">IO(f(x))</code> and <code class="language-plaintext highlighter-rouge">IO.pure(x).flatMap(f)</code> is equivalent with <code class="language-plaintext highlighter-rouge">IO.suspend(f(x))</code>.</p>

<p>But you should not rely on this behavior, because it is NOT described by the laws required by the <code class="language-plaintext highlighter-rouge">Sync</code> type class and those laws are the only guarantees of behavior that you get. For example the above equivalence might be broken in the future in regards to error handling. So this behavior is currently there for safety reasons, but you should regard it as an implementation detail that could change in the future.</p>

<p>Stick with pure functions.</p>



<link rel="stylesheet" type="text/css" href="/cats-effect/css/toc.css"></link>
<script type="text/javascript" src="/cats-effect/js/toc.js"></script>
</section></div></div></div></div><script src="/cats-effect/highlight/highlight.pack.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script src="/cats-effect/js/toc.js"></script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats-effect'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats-effect/js/docs.js"></script></body></html>